---
phase: 05-sound-and-polish
plan: "02"
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/hooks/useDrag.ts
  - src/screens/GameScreen/GameScreen.tsx
  - src/screens/GameScreen/GameScreen.module.css
  - src/components/Board/Board.tsx
  - src/components/Board/Board.module.css
  - src/components/ControlBar/ControlBar.tsx
autonomous: true
requirements:
  - REQ-033
  - REQ-034
  - REQ-035
  - REQ-036
  - REQ-037
  - REQ-023
  - NFR-003

must_haves:
  truths:
    - "Slide sound plays exactly once per successful vehicle move (not during drag, only on snap commit)"
    - "Level-start sound plays when a new puzzle loads"
    - "Win sound plays at the moment of win detection"
    - "Confetti burst and board glow trigger on win, WinModal appears ~2 seconds later"
    - "Board is input-locked (pointer-events disabled) during the 2-second win animation"
    - "GameHeader appears at the top of the game screen with mute, help, and about buttons"
    - "Mute button no longer exists in ControlBar; it lives only in GameHeader"
  artifacts:
    - path: "src/hooks/useDrag.ts"
      provides: "Drag hook with slide sound on move commit"
      contains: "soundService.playSlide"
    - path: "src/screens/GameScreen/GameScreen.tsx"
      provides: "Game screen with win sequence (confetti + delay + WinModal) and level-start sound"
      contains: "isWinAnimating"
    - path: "src/components/Board/Board.tsx"
      provides: "Board with win glow class and input lock during animation"
      contains: "winGlow"
    - path: "src/components/ControlBar/ControlBar.tsx"
      provides: "ControlBar without mute button (moved to GameHeader)"
  key_links:
    - from: "src/hooks/useDrag.ts"
      to: "src/services/soundService.ts"
      via: "soundService.playSlide() inside snapTimerRef callback when move actually occurred"
      pattern: "soundService\\.playSlide"
    - from: "src/screens/GameScreen/GameScreen.tsx"
      to: "canvas-confetti"
      via: "confetti() call in win detection useEffect"
      pattern: "confetti\\("
    - from: "src/screens/GameScreen/GameScreen.tsx"
      to: "src/components/Board/Board.tsx"
      via: "isWinAnimating prop passed to Board to lock input"
      pattern: "isWinAnimating"
    - from: "src/components/Board/Board.tsx"
      to: "src/components/Board/Board.module.css"
      via: "styles.winGlow class applied when isWinAnimating=true"
      pattern: "winGlow"
---

<objective>
Wire all audio triggers into the game flow, implement the win celebration sequence (confetti + board glow + 2-second delay before WinModal), integrate GameHeader into the game screen, and remove the mute stub from ControlBar.

Purpose: This is where Phase 5 becomes audible and animated. After this plan, moving a vehicle plays a sound, winning shows confetti + glow before the WinModal, every new puzzle announces itself with a start sound, and the header has the permanent mute control.

Output: Modified useDrag.ts (slide sound), modified GameScreen.tsx (win sequence + level-start sound + GameHeader), modified Board.tsx (win glow + input lock), modified ControlBar.tsx (mute removed).
</objective>

<execution_context>
@C:/Users/omerb/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omerb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-sound-and-polish/05-CONTEXT.md
@.planning/phases/05-sound-and-polish/05-RESEARCH.md
@.planning/phases/05-sound-and-polish/05-01-SUMMARY.md
@src/hooks/useDrag.ts
@src/screens/GameScreen/GameScreen.tsx
@src/components/Board/Board.tsx
@src/components/Board/Board.module.css
@src/components/ControlBar/ControlBar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire slide sound into useDrag and level-start sound into GameScreen puzzle load</name>
  <files>src/hooks/useDrag.ts, src/screens/GameScreen/GameScreen.tsx</files>
  <action>
**useDrag.ts — slide sound on move commit:**

Import soundService at the top of the file:
```typescript
import { soundService } from '../services/soundService';
```

In the `snapTimerRef` callback (inside `onPointerUp`), call `soundService.playSlide()` ONLY when the vehicle actually moved (the `if (newRow !== startRow || newCol !== startCol)` branch). This fires ONCE per valid move, never during drag:

```typescript
snapTimerRef.current = setTimeout(() => {
  snapTimerRef.current = null;
  el.style.transition = '';
  el.style.transform = '';
  el.style.willChange = '';
  el.style.zIndex = '';

  if (newRow !== startRow || newCol !== startCol) {
    soundService.playSlide();  // <- ADD HERE, before onMoveCommit
    onMoveCommitRef.current(vehicleIdRef.current, newRow, newCol);
  }
}, SNAP_DURATION_MS);
```

CRITICAL: Do NOT call playSlide() in onPointerMove — that fires 60fps during drag and would create a cacophony. Only call it in the snapTimerRef callback after a confirmed cell change.

**GameScreen.tsx — level-start sound on puzzle load:**

Import soundService:
```typescript
import { soundService } from '../../services/soundService';
```

In the puzzle load useEffect (the one that calls `loadPuzzle(puzzle.gridString, puzzle.minMoves)`), add `soundService.playStart()` AFTER `loadPuzzle()` is called. This fires when the user navigates to a puzzle — which IS a user gesture (they clicked a puzzle tile), so AudioContext is already unlocked:

```typescript
useEffect(() => {
  if (!puzzleId) {
    navigate('/puzzles', { replace: true });
    return;
  }
  const puzzle = getPuzzleById(puzzleId);
  if (!puzzle) {
    navigate('/puzzles', { replace: true });
    return;
  }
  loadPuzzle(puzzle.gridString, puzzle.minMoves);
  soundService.playStart();  // <- ADD HERE
  setShowWinModal(false);
  setIsNewPersonalBest(false);
}, [puzzleId, loadPuzzle, navigate]);
```
  </action>
  <verify>
Run: `npx tsc --noEmit` — zero TypeScript errors in useDrag.ts and GameScreen.tsx.
Run: `npm run dev`, navigate to a puzzle — level-start sound plays on load.
Drag a vehicle to a new cell — slide sound plays exactly once after release.
  </verify>
  <done>useDrag.ts calls soundService.playSlide() inside the snapTimerRef callback only when newRow !== startRow || newCol !== startCol. GameScreen.tsx calls soundService.playStart() in the puzzle load useEffect after loadPuzzle(). TypeScript compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Implement win celebration sequence and integrate GameHeader</name>
  <files>
    src/screens/GameScreen/GameScreen.tsx
    src/screens/GameScreen/GameScreen.module.css
    src/components/Board/Board.tsx
    src/components/Board/Board.module.css
    src/components/ControlBar/ControlBar.tsx
  </files>
  <action>
**GameScreen.tsx — win sequence (confetti + glow + 2s delay before WinModal):**

Add these imports at the top:
```typescript
import confetti from 'canvas-confetti';
import { GameHeader } from '../../components/GameHeader/GameHeader';
```

Add `isWinAnimating` state alongside `showWinModal`:
```typescript
const [isWinAnimating, setIsWinAnimating] = useState(false);
```

Replace the current win detection useEffect with this version that delays WinModal by 2 seconds:
```typescript
useEffect(() => {
  if (state?.isWon && puzzleId && state.startTime && state.endTime) {
    const timeMs = state.endTime - state.startTime;
    const moves = state.moveCount;

    // Compute personal best BEFORE recordCompletion mutates the store
    const prevBest = getBest(puzzleId);
    const newPB =
      !prevBest ||
      moves < prevBest.bestMoves ||
      (moves === prevBest.bestMoves && timeMs < prevBest.bestTimeMs);

    setIsNewPersonalBest(newPB);
    recordCompletion(puzzleId, moves, timeMs);
    void submitScore(puzzleId, moves, timeMs, minMoves);

    // Win celebration sequence (user decision: animation first, then WinModal)
    soundService.playWin();

    confetti({
      particleCount: 150,
      spread: 100,
      origin: { x: 0.5, y: 0.6 },
      colors: ['#e63946', '#f5c842', '#4a90d9', '#2ecc71', '#9b59b6'],
      gravity: 1.2,
      scalar: 0.9,
    });

    setIsWinAnimating(true);

    const timer = setTimeout(() => {
      setIsWinAnimating(false);
      setShowWinModal(true);
    }, 2000);

    return () => clearTimeout(timer);
  }
}, [state?.isWon]);
```

Pass `isWinAnimating` to Board:
```tsx
<Board isWinAnimating={isWinAnimating} />
```

Add GameHeader to the JSX (above GameHUD):
```tsx
return (
  <div className={styles.container}>
    <GameHeader />
    <GameHUD />
    <Board isWinAnimating={isWinAnimating} />
    <ControlBar />
    {showWinModal && puzzleId && (
      <WinModal ... />
    )}
  </div>
);
```

Also reset `isWinAnimating` when a new puzzle loads (add to the puzzle load useEffect):
```typescript
setIsWinAnimating(false);
```

**Board.tsx — accept isWinAnimating prop, apply winGlow class, lock input:**

Update Board to accept the prop:
```typescript
interface BoardProps {
  isWinAnimating: boolean;
}

export function Board({ isWinAnimating }: BoardProps) {
  // ...existing code...

  return (
    <div className={styles.boardWrapper} data-board>
      <div className={[styles.board, isWinAnimating ? styles.winGlow : ''].filter(Boolean).join(' ')}>
        {/* ...existing JSX... */}
        {/* Vehicle layer with input lock during win animation */}
        <div
          className={styles.vehicleLayer}
          style={isWinAnimating ? { pointerEvents: 'none' } : undefined}
        >
          {state?.vehicles.map((vehicle) => (
            <Vehicle key={vehicle.id} vehicle={vehicle} />
          ))}
        </div>
      </div>
    </div>
  );
}
```

Note: vehicleLayer already has `pointer-events: none` in CSS. During win animation, we want to ensure the ENTIRE board wrapper also blocks input — add inline style to boardWrapper div as well:
```tsx
<div
  className={styles.boardWrapper}
  data-board
  style={isWinAnimating ? { pointerEvents: 'none' } : undefined}
>
```

**Board.module.css — add winGlow keyframes:**

Append to the existing Board.module.css:
```css
/* Win celebration glow animation (2s, matches WinModal delay) */
@keyframes winGlow {
  0%   { box-shadow: 0 8px 32px rgba(0,0,0,0.45), 0 2px 6px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.08), 0 0 0 rgba(245,200,66,0); }
  20%  { box-shadow: 0 8px 32px rgba(0,0,0,0.45), 0 2px 6px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.08), 0 0 60px rgba(245,200,66,0.8), 0 0 120px rgba(245,200,66,0.4); }
  60%  { box-shadow: 0 8px 32px rgba(0,0,0,0.45), 0 2px 6px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.08), 0 0 40px rgba(245,200,66,0.5); }
  100% { box-shadow: 0 8px 32px rgba(0,0,0,0.45), 0 2px 6px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.08), 0 0 0 rgba(245,200,66,0); }
}

.winGlow {
  animation: winGlow 2s ease-out forwards;
}
```

**ControlBar.tsx — remove mute button:**

Remove the `MUTE_KEY`, `isMuted` state, and `handleMute` function. Remove the mute `<button>` from the JSX. The mute control now lives exclusively in GameHeader per the user decision. Keep undo, reset, and back buttons as-is.

**GameScreen.module.css — ensure container accommodates header:**

The existing `.container` should be a flex column. Verify it exists; if not, add:
```css
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  min-height: 100vh;
  padding: 16px;
  gap: 8px;
}
```

If `.container` already exists with different values, keep existing styles and only add/adjust what's needed to accommodate the new GameHeader above GameHUD.
  </action>
  <verify>
Run: `npx tsc --noEmit` — zero TypeScript errors.
Run: `npm run build` — production build succeeds.
Manual check: Win a puzzle — confetti fires, board glows gold, WinModal appears ~2 seconds later. Board is unresponsive to drag during animation. GameHeader visible at top with mute/help/about. ControlBar no longer has mute button.
  </verify>
  <done>Win sequence: confetti fires at t=0, board glows for 2s, WinModal appears at t=2000ms. Board input is locked (pointer-events: none on boardWrapper) during animation. GameHeader appears above GameHUD in GameScreen. ControlBar has only undo, reset, back buttons. TypeScript and build pass with no errors.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero errors across all modified files.
2. `npm run build` — build succeeds.
3. Navigate to a puzzle: level-start sound plays.
4. Drag a vehicle to a new cell: slide sound plays once on snap.
5. Win a puzzle: win sound + confetti + board glow → 2 seconds pause → WinModal appears.
6. During win animation: dragging vehicles does nothing (board locked).
7. GameHeader is visible at top of game screen with mute, ?, i buttons.
8. ControlBar no longer has a mute button.
</verification>

<success_criteria>
- Slide sound fires exactly once per move commit in useDrag snapTimerRef callback
- Level-start sound fires after loadPuzzle() in puzzle load useEffect
- Win sound + confetti + winGlow class trigger in win detection useEffect at t=0
- WinModal appears at t=2000ms via setTimeout (timer cleared in useEffect cleanup)
- isWinAnimating=true sets pointer-events:none on boardWrapper during animation
- GameHeader replaces ControlBar mute button — mute lives in the header
- `npm run build` succeeds with no TypeScript or bundler errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-sound-and-polish/05-02-SUMMARY.md`
</output>
