---
phase: 01-game-engine
plan: 03
type: tdd
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/engine/solver.ts
  - src/engine/__tests__/solver.test.ts
  - src/engine/__tests__/integration.test.ts
  - src/engine/index.ts
autonomous: true

must_haves:
  truths:
    - "BFS solver finds the optimal (minimum) move count for any solvable Rush Hour puzzle"
    - "Solver reports unsolvable for puzzles where X cannot reach the exit"
    - "Solver handles the standard grid string format as input"
    - "Solver is a pure function with no side effects or runtime dependencies"
  artifacts:
    - path: "src/engine/solver.ts"
      provides: "BFS solver that computes optimal move count for Rush Hour puzzles"
      exports: ["solvePuzzle"]
    - path: "src/engine/__tests__/solver.test.ts"
      provides: "Unit tests for solver correctness and edge cases"
      min_lines: 60
  key_links:
    - from: "src/engine/solver.ts"
      to: "src/engine/board.ts"
      via: "imports parseGridString, buildOccupancyGrid, vehicleCells for state enumeration"
      pattern: "import.*from.*board"
    - from: "src/engine/solver.ts"
      to: "src/engine/types.ts"
      via: "imports Vehicle, Position types"
      pattern: "import.*from.*types"
---

<objective>
Implement a BFS solver that computes the optimal (minimum) move count for any Rush Hour puzzle configuration.

Purpose: The solver is essential for REQ-028 (each puzzle has a known minimum move count) and REQ-029 (all puzzles validated as solvable). It runs at build time to pre-compute optimal counts and reject unsolvable puzzles. It shares the engine's types and grid model but is not a runtime feature.

Output: A tested BFS solver function that takes a grid string and returns the optimal move count or reports unsolvable.
</objective>

<execution_context>
@C:/Users/omerb/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omerb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-game-engine/01-CONTEXT.md
@.planning/phases/01-game-engine/01-01-SUMMARY.md
@.planning/phases/01-game-engine/01-02-SUMMARY.md
@src/engine/types.ts
@src/engine/board.ts
@src/engine/engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: BFS solver with TDD</name>
  <files>src/engine/solver.ts, src/engine/__tests__/solver.test.ts</files>
  <action>
TDD: Write tests FIRST, then implement.

**RED phase -- write failing tests:**

`solvePuzzle(gridString: string)` -> `{ solvable: boolean; minMoves: number }`:

1. Already-solved puzzle -- X at exit (cols 4-5, row 2):
   Row r, col c = index r*6 + c. X at row 2 cols 4-5 = indices 16 and 17.
   Grid: `".".repeat(16) + "XX" + ".".repeat(18)` = `"................XX.................."` (16 + 2 + 18 = 36)
   solvePuzzle returns { solvable: true, minMoves: 0 }.

2. One-move puzzle -- X at row 2 cols 3-4, needs one right slide to cols 4-5:
   X at indices 15 and 16.
   Grid: `".".repeat(15) + "XX" + ".".repeat(19)` = `"...............XX..................."` (15 + 2 + 19 = 36)
   solvePuzzle returns { solvable: true, minMoves: 1 }.

3. Known puzzle with reasonable solution range:
   Classic beginner puzzle `"AA.O..B..OXXB..O..CPPP.CDDEEL.FFG.L"`.
   solvePuzzle returns { solvable: true, minMoves: N } where N is between 5 and 20 (beginner puzzle).
   This validates the solver runs to completion without timeout on a realistic puzzle.

4. Unsolvable puzzle -- board fully packed, X jammed on row 2 with no way to clear any blocker:
   Build a 6x6 board where every cell is filled with horizontal size-2 vehicles (all 18 vehicles):
   - Row 0: AA BB CC  (A at cols 0-1, B at cols 2-3, C at cols 4-5)
   - Row 1: DD EE FF
   - Row 2: GG XX HH  (X at cols 2-3, blocked left by GG and right by HH)
   - Row 3: II JJ KK
   - Row 4: LL MM NN
   - Row 5: OO PP QQ

   Grid string (36 chars): `"AABBCCDDEEFFGGXXHHIIJJKKLLMMNNOOPPQQ"`
   Verify length: 6 rows x 6 cols = 36 chars. Each row is 6 chars (3 x size-2 vehicle).
   No vehicle can move (each horizontal car is flanked by other cars with no gap). X is stuck.
   solvePuzzle returns { solvable: false, minMoves: -1 }.

5. Performance guard: solvePuzzle on the classic beginner puzzle completes within 5 seconds
   (use vitest's built-in timeout or Date.now() check -- not a strict unit assertion, just a
   safeguard to catch infinite loops during development).

**GREEN phase -- implement:**

`solvePuzzle(gridString)`:

1. Parse grid string into vehicles using `parseGridString`
2. Check if already solved (X occupies both col 4 and col 5 on row 2) -> return { solvable: true, minMoves: 0 }
3. BFS:
   - State = serialized vehicle positions. Use the 36-char grid string format itself as the hash key
     (rebuild from vehicles -- compact and directly comparable). This is Claude's discretion on
     "BFS solver optimization strategy".
   - Queue of { vehicles: Vehicle[], depth: number }
   - Visited = Set<string> seeded with initial state string
   - For each state: enumerate all possible single moves for all vehicles
     (slide each vehicle 1-5 cells in each valid direction along its axis, stopping at
     collisions/bounds -- each unique destination = 1 move per user decision)
   - Check win after each move (X at cols 4-5 on row 2)
   - Return { solvable: true, minMoves: depth } when win found
4. If queue exhausted: return { solvable: false, minMoves: -1 }

IMPORTANT per user decision: Solver returns optimal move count ONLY -- no solution path stored.
The return type is `{ solvable: boolean; minMoves: number }`.
  </action>
  <verify>
`npx vitest run` -- all solver tests pass. Already-solved puzzle returns 0, one-move puzzle returns 1, packed board returns solvable: false. `npx tsc --noEmit` compiles.
  </verify>
  <done>BFS solver correctly finds optimal move count for solvable puzzles and reports unsolvable for impossible configurations. All tests green.</done>
</task>

<task type="auto">
  <name>Task 2: Barrel export and integration smoke test</name>
  <files>src/engine/index.ts, src/engine/__tests__/integration.test.ts</files>
  <action>
Update `src/engine/index.ts` to export the full public API:
- All types from types.ts (Vehicle, GameState, MoveResult, MoveEntry, PuzzleDefinition, Orientation, Position)
- parseGridString, buildOccupancyGrid, vehicleCells from board.ts
- GameEngine from engine.ts
- solvePuzzle from solver.ts

Create `src/engine/__tests__/integration.test.ts` with a small integration smoke test:

1. Import GameEngine and solvePuzzle from `'../index'` (NOT from individual module files -- tests the barrel)
2. Use puzzle `"AA.O..B..OXXB..O..CPPP.CDDEEL.FFG.L"`
3. Run solvePuzzle on the grid string to get { solvable, minMoves }
4. Create a new GameEngine with the same grid string
5. Assert engine initializes with isWon = false, moveCount = 0
6. Play at least one valid move using engine.move(...)
7. Verify the move returns { success: true }
8. This proves board parser, GameEngine, and solver all share the same type system and grid format

Also verify the barrel export works: `import { GameEngine, solvePuzzle, parseGridString } from '../index'` compiles and resolves all public API symbols.
  </action>
  <verify>
`npx vitest run` -- all tests pass including integration test. `npx tsc --noEmit` compiles. Import from `src/engine/index.ts` resolves all public API symbols.
  </verify>
  <done>All engine modules export cleanly from barrel. Integration test proves board parser, GameEngine, and solver work together on the same puzzle. Full public API accessible from single import.</done>
</task>

</tasks>

<verification>
- `npx vitest run` passes with all tests green (board + engine + solver + integration)
- `npx tsc --noEmit` passes with zero errors
- solvePuzzle returns correct optimal move count for trivial, simple, and complex puzzles
- solvePuzzle returns { solvable: false } for unsolvable puzzles
- All public API exports available from src/engine/index.ts
- Integration test proves all modules work together
- No React/Firebase dependencies anywhere
</verification>

<success_criteria>
- BFS solver finds optimal solutions for solvable puzzles
- Solver correctly identifies unsolvable puzzles
- Full engine API exported from single barrel (types, board, engine, solver)
- Integration test proves end-to-end: parse -> play -> solve on same puzzle
- All Phase 1 success criteria from ROADMAP.md are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-game-engine/01-03-SUMMARY.md`
</output>
