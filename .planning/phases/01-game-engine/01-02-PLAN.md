---
phase: 01-game-engine
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/engine/engine.ts
  - src/engine/__tests__/engine.test.ts
  - src/engine/index.ts
autonomous: true

must_haves:
  truths:
    - "Vehicles slide only along their orientation axis (horizontal vehicles move left/right, vertical move up/down)"
    - "Moves that would cause overlap with another vehicle or go out of bounds are rejected with a reason"
    - "Win condition fires when vehicle X occupies columns 4-5 on row 2 (right edge exit)"
    - "Move counter increments on each valid move and does NOT decrement on undo"
    - "Timer starts (startTime set) on the first valid move and stops (endTime set) on win"
    - "Undo restores the previous vehicle positions but increments the move counter"
    - "Reset restores the puzzle to its initial state with moveCount 0 and cleared timer"
  artifacts:
    - path: "src/engine/engine.ts"
      provides: "GameEngine class with move, undo, reset, timer, win detection"
      exports: ["GameEngine"]
    - path: "src/engine/__tests__/engine.test.ts"
      provides: "Comprehensive unit tests for all engine operations"
      min_lines: 150
  key_links:
    - from: "src/engine/engine.ts"
      to: "src/engine/board.ts"
      via: "imports parseGridString, buildOccupancyGrid, vehicleCells for collision detection"
      pattern: "import.*from.*board"
    - from: "src/engine/engine.ts"
      to: "src/engine/types.ts"
      via: "imports Vehicle, GameState, MoveResult, MoveEntry types"
      pattern: "import.*from.*types"
---

<objective>
Build the GameEngine class that manages all game state: move validation with collision detection, win detection, move counting, timer tracking, undo, and reset.

Purpose: This is the core gameplay logic. Every user interaction in the final game flows through this engine. It must correctly enforce Rush Hour rules: vehicles slide only on their axis, cannot overlap, and the game is won when X reaches the exit.

Output: Fully tested GameEngine class that accepts grid strings and processes moves, undo, and reset operations.
</objective>

<execution_context>
@C:/Users/omerb/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omerb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-game-engine/01-CONTEXT.md
@.planning/phases/01-game-engine/01-01-SUMMARY.md
@src/engine/types.ts
@src/engine/board.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: GameEngine class with TDD -- move validation and win detection</name>
  <files>src/engine/engine.ts, src/engine/__tests__/engine.test.ts</files>
  <action>
TDD: Write tests FIRST, then implement.

**RED phase -- write failing tests for GameEngine:**

Constructor tests:
- `new GameEngine(gridString)` initializes with parsed vehicles, moveCount 0, empty moveHistory, startTime null, endTime null, isWon false
- `engine.getState()` returns an immutable GameState snapshot (modifying the returned object does not affect engine internals)

Move tests (using puzzle `"AA.O..B..OXXB..O..CPPP.CDDEEL.FFG.L"`):
- `engine.move(vehicleId, newRow, newCol)` returns `MoveResult { success: true, state, reason: undefined }` for valid moves
- Moving horizontal vehicle A left to col 0 row 0: success (A is at col 0 already in this puzzle, so test with a puzzle where A can move)
- Use simpler test puzzles for isolated move testing:
  - `"..AA................................"` -- car A at row 0, cols 2-3, can move left or right
  - Move A to col 0: success (slides left 2)
  - Move A to col 4: success (slides right 2)
- Collision: `"AABB................................"` -- A at 0-1, B at 2-3. Moving A to col 2: fails with reason containing "blocked" or "collision"
- Out of bounds: Moving A to col -1 or col 5 (size 2 at col 5 goes to col 6): fails with reason
- Wrong axis: Moving horizontal vehicle to a different row: fails with reason
- Vertical vehicle test: `"A.....A.....A......................."` -- vertical truck A rows 0-2, col 0. Can move down but not left/right

Win detection:
- Puzzle with X near exit: `"....XX.............................."`  -- X at row 0 cols 4-5. This is NOT a win (X must be on row 2)
- Proper win puzzle: `"............XX......................"` -- X at row 2 cols 0-1. Move X to col 4 -> isWon = true
- Win sets endTime to a non-null value
- After win, further moves are rejected with reason "game already won"

Move counter:
- Each valid move increments moveCount by 1
- Invalid moves do NOT increment moveCount
- Multi-cell slide (e.g., moving 3 cells in one move) still counts as 1 move (per user decision)

Timer:
- Before any move: startTime is null
- After first valid move: startTime is set to a number (timestamp)
- startTime does not change on subsequent moves
- On win: endTime is set

**GREEN phase -- implement GameEngine class:**

```typescript
class GameEngine {
  constructor(gridString: string)    // parses grid, initializes state
  getState(): GameState              // returns immutable snapshot (deep clone or frozen)
  move(vehicleId: string, newRow: number, newCol: number): MoveResult
}
```

Move validation logic:
1. Check game not already won
2. Find vehicle by id
3. Validate axis constraint: horizontal vehicles must keep same row, vertical must keep same col
4. Validate bounds: all new cells must be within 0-5 range
5. Build occupancy grid, check all intermediate AND destination cells are free (vehicle must slide through, not teleport -- check path is clear)
6. If valid: update vehicle position, record MoveEntry, increment moveCount, set startTime if first move, check win condition
7. If invalid: return { success: false, state: currentState, reason: "descriptive reason" }

Win check: After each move, check if vehicle 'X' occupies col 4 and col 5 on row 2 (0-indexed). If so, set isWon = true and endTime.

CRITICAL: Per user decision, the move validates the PATH is clear, not just the destination. If a vehicle at col 0 wants to move to col 4, cols 1-3 must all be clear.
  </action>
  <verify>
`npx vitest run` -- all engine tests pass covering: valid moves, collisions, bounds, axis constraint, win detection, move counter, timer. `npx tsc --noEmit` compiles.
  </verify>
  <done>GameEngine correctly validates moves along orientation axis, rejects overlaps and out-of-bounds, detects win when X reaches right edge of row 2, tracks move count and timer.</done>
</task>

<task type="auto">
  <name>Task 2: Undo and reset with TDD</name>
  <files>src/engine/engine.ts, src/engine/__tests__/engine.test.ts, src/engine/index.ts</files>
  <action>
TDD: Add tests FIRST to the existing engine test file, then implement.

**RED phase -- write failing tests:**

Undo tests:
- `engine.undo()` returns MoveResult
- After one move, undo restores vehicle to previous position
- After undo, moveCount is INCREMENTED (not decremented) -- per user decision: "Move counter does NOT decrement on undo. All moves count, including undone ones."
- Undo on fresh game (no moves): returns { success: false, reason: "no moves to undo" }
- Multiple undos: can undo entire move history one step at a time
- Undo after undo: each undo increments moveCount
- After win + undo: isWon becomes false again, endTime resets to null (player can continue)
- Undo does NOT affect startTime (timer keeps running from first move)

Reset tests:
- `engine.reset()` returns GameState
- After moves, reset restores ALL vehicles to initial positions (from original grid string)
- Reset sets moveCount to 0, clears moveHistory, sets startTime to null, endTime to null, isWon to false
- After reset, player can start fresh -- first move sets startTime again

No redo (per user decision -- undo supported, no redo).

**GREEN phase -- implement:**

Add to GameEngine class:
```typescript
undo(): MoveResult    // pops last move, restores position, increments moveCount
reset(): GameState    // restores initial state completely
```

Undo implementation: Pop last MoveEntry from moveHistory, restore that vehicle to its from position, increment moveCount (yes, increment -- per user decision), recheck win condition (in case undo reverses a win).

Reset implementation: Re-parse original gridString, reset all state fields to initial values.

Export GameEngine from `src/engine/index.ts`.
  </action>
  <verify>
`npx vitest run` -- all tests pass including new undo/reset tests. Total test count should be 25+. `npx tsc --noEmit` compiles.
  </verify>
  <done>Undo restores vehicle positions while incrementing move count (per user decision). Reset fully restores initial puzzle state. No redo functionality. GameEngine exported from barrel.</done>
</task>

</tasks>

<verification>
- `npx vitest run` passes with 25+ tests, all green
- `npx tsc --noEmit` passes with zero errors
- GameEngine constructor accepts grid string, initializes clean state
- Valid moves return { success: true, state } with updated positions and incremented moveCount
- Invalid moves return { success: false, state, reason } without state changes
- Path validation: vehicle cannot teleport past blockers
- Win detected when X vehicle reaches cols 4-5 on row 2
- Timer: startTime set on first move, endTime set on win
- Undo: restores position, increments moveCount (does NOT decrement)
- Reset: restores to initial grid string state, moveCount 0, timer cleared
- GameEngine exported from src/engine/index.ts
</verification>

<success_criteria>
- GameEngine class fully implements Rush Hour rules: axis-constrained movement, collision detection, boundary enforcement
- Win detection correctly identifies when X reaches the exit
- Move counter and timer tracking work per user decisions (undo increments, reset clears)
- Undo and reset operations are correct and tested
- 25+ unit tests all passing
</success_criteria>

<output>
After completion, create `.planning/phases/01-game-engine/01-02-SUMMARY.md`
</output>
