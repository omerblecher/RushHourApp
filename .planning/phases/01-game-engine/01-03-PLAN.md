---
phase: 01-game-engine
plan: 03
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/engine/solver.ts
  - src/engine/__tests__/solver.test.ts
  - src/engine/index.ts
autonomous: true

must_haves:
  truths:
    - "BFS solver finds the optimal (minimum) move count for any solvable Rush Hour puzzle"
    - "Solver reports unsolvable for puzzles where X cannot reach the exit"
    - "Solver handles the standard grid string format as input"
    - "Solver is a pure function with no side effects or runtime dependencies"
  artifacts:
    - path: "src/engine/solver.ts"
      provides: "BFS solver that computes optimal move count for Rush Hour puzzles"
      exports: ["solvePuzzle"]
    - path: "src/engine/__tests__/solver.test.ts"
      provides: "Unit tests for solver correctness and edge cases"
      min_lines: 60
  key_links:
    - from: "src/engine/solver.ts"
      to: "src/engine/board.ts"
      via: "imports parseGridString, buildOccupancyGrid, vehicleCells for state enumeration"
      pattern: "import.*from.*board"
    - from: "src/engine/solver.ts"
      to: "src/engine/types.ts"
      via: "imports Vehicle, Position types"
      pattern: "import.*from.*types"
---

<objective>
Implement a BFS solver that computes the optimal (minimum) move count for any Rush Hour puzzle configuration.

Purpose: The solver is essential for REQ-028 (each puzzle has a known minimum move count) and REQ-029 (all puzzles validated as solvable). It runs at build time to pre-compute optimal counts and reject unsolvable puzzles. It shares the engine's types and grid model but is not a runtime feature.

Output: A tested BFS solver function that takes a grid string and returns the optimal move count or reports unsolvable.
</objective>

<execution_context>
@C:/Users/omerb/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omerb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-game-engine/01-CONTEXT.md
@.planning/phases/01-game-engine/01-01-SUMMARY.md
@src/engine/types.ts
@src/engine/board.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: BFS solver with TDD</name>
  <files>src/engine/solver.ts, src/engine/__tests__/solver.test.ts</files>
  <action>
TDD: Write tests FIRST, then implement.

**RED phase -- write failing tests:**

`solvePuzzle(gridString: string)` -> `{ solvable: boolean; minMoves: number }`:

1. Trivial puzzle -- X already at exit:
   - `"............XX......................"` with X at row 2 cols 0-1 is NOT solved (X needs cols 4-5)
   - `"..........XXXX......................"` is invalid (X is size 2, not 4)
   - Create a grid where X is at cols 4-5 row 2: `"..............XX...................."` -- already solved, minMoves = 0

2. One-move puzzle:
   - `"...............XX..................."` -- X at row 2 cols 3-4, one move right to cols 4-5 -> minMoves = 1
   Wait, need to verify: row 2 = chars 12-17. cols 4-5 on row 2 = indices 16-17.
   Build the string carefully:
   - Row 0 (indices 0-5): `"......"`
   - Row 1 (indices 6-11): `"......"`
   - Row 2 (indices 12-17): `"...XX."` -> X at cols 3-4, needs to slide to cols 4-5 -> 1 move
   - Rows 3-5: `".................."`
   Grid: `"....................XX..............."` -- wait, let me compute: 12 dots + XX + 1 dot + 18 dots = 33 chars. Wrong.

   Just use index math: 36-char string. Row r, col c = index r*6 + c.
   X at row 2, col 3-4: indices 15, 16.
   Build: `".".repeat(15) + "XX" + ".".repeat(19)` = `"...............XX..................."`  (15 + 2 + 19 = 36)
   Moving X right 1 -> col 4-5 (indices 16, 17) -> win. minMoves = 1.

3. Known puzzle with known solution:
   - Classic beginner puzzle `"AA.O..B..OXXB..O..CPPP.CDDEEL.FFG.L"`
   - This is a well-known puzzle. The solver should find an optimal solution. We can verify by checking the result is reasonable (e.g., between 5-15 moves for a beginner puzzle).
   - Better approach: create a simple 2-move puzzle and verify exactly.

4. Simple multi-move puzzle:
   - Design a puzzle where X must wait for one blocker to move:
   - Row 2: `"OXXO.."` -- O at col 0 (vertical, extends up/down), X at cols 1-2, O at col 3 (vertical). X blocked right by O at col 3. O at col 3 must move, then X slides.
   - Full grid: put vertical vehicle O spanning rows 1-3 at col 3:
   ```
   Row 0: ......
   Row 1: ...O..
   Row 2: .XX O..  -> .XXO..
   Row 3: ...O..
   Row 4: ......
   Row 5: ......
   ```
   Grid: `"......` + `...O..` + `.XXO..` + `...O..` + `......` + `......"`
   = `"..........O...XXO.....O..........."`
   Hmm, let me just compute indices. I'll let the test use string construction helpers.

   Actually, for the test just use a known trivial puzzle. The exact grid strings can be built in the test using a helper.

5. Unsolvable puzzle -- X completely blocked with no way to clear:
   - `"AABBCCXXDDEE.FFGGHH.IIJJKK.LLMMNN"` -- board completely full except row 2 has X jammed. Solver returns { solvable: false, minMoves: -1 }.
   - Simpler: create a 2-row blocker scenario where X is permanently stuck.

6. Performance: solver completes within 5 seconds for a complex puzzle (not a unit test, but a timeout guard).

**GREEN phase -- implement:**

`solvePuzzle(gridString)`:

1. Parse grid string into vehicles using `parseGridString`
2. Check if already solved (X at cols 4-5 on row 2) -> return { solvable: true, minMoves: 0 }
3. BFS:
   - State = serialized vehicle positions (e.g., sorted "vehicleId:row:col" joined, or re-serialize as grid string)
   - Use a Set for visited states (string hashing for efficiency -- per Claude's discretion on "BFS solver optimization strategy")
   - Queue of { vehicles: Vehicle[], depth: number }
   - For each state: enumerate all possible single moves for all vehicles (slide each vehicle 1-5 cells in each valid direction along its axis, stopping at collisions/bounds)
   - Each unique slide = 1 move (per user decision: any single slide = 1 move regardless of distance)
   - Check win after each move
   - Return { solvable: true, minMoves: depth } when win found
4. If queue exhausted: return { solvable: false, minMoves: -1 }

State serialization optimization (Claude's discretion): Use the 36-char grid string format itself as the hash key -- rebuild it from vehicles. This is compact and directly comparable.

IMPORTANT per user decision: Solver returns optimal move count ONLY, no solution path stored. The return type is `{ solvable: boolean; minMoves: number }`.
  </action>
  <verify>
`npx vitest run` -- all solver tests pass. Trivial puzzle returns 0, one-move puzzle returns 1, unsolvable returns solvable: false. `npx tsc --noEmit` compiles.
  </verify>
  <done>BFS solver correctly finds optimal move count for solvable puzzles and reports unsolvable for impossible configurations. All tests green.</done>
</task>

<task type="auto">
  <name>Task 2: Barrel export and integration smoke test</name>
  <files>src/engine/index.ts, src/engine/__tests__/integration.test.ts</files>
  <action>
Update `src/engine/index.ts` to export the full public API:
- All types from types.ts (Vehicle, GameState, MoveResult, MoveEntry, PuzzleDefinition, Orientation, Position)
- parseGridString, buildOccupancyGrid, vehicleCells from board.ts
- GameEngine from engine.ts
- solvePuzzle from solver.ts

Create `src/engine/__tests__/integration.test.ts` with a small integration smoke test:

1. Parse a known puzzle grid string
2. Create a GameEngine with it
3. Run solvePuzzle on the same grid string to get optimal move count
4. Play through the puzzle in the engine making valid moves
5. Verify the engine reaches win state
6. Verify moveCount >= optimal move count from solver (player can't beat optimal)

This proves all three modules (board, engine, solver) work together correctly using the same types and grid format.

Also verify the barrel export works: `import { GameEngine, solvePuzzle, parseGridString } from '../index'` compiles and functions.
  </action>
  <verify>
`npx vitest run` -- all tests pass including integration test. `npx tsc --noEmit` compiles. Import from `src/engine/index.ts` resolves all public API symbols.
  </verify>
  <done>All engine modules export cleanly from barrel. Integration test proves board parser, GameEngine, and solver work together on the same puzzle. Full public API accessible from single import.</done>
</task>

</tasks>

<verification>
- `npx vitest run` passes with all tests green (board + engine + solver + integration)
- `npx tsc --noEmit` passes with zero errors
- solvePuzzle returns correct optimal move count for trivial, simple, and complex puzzles
- solvePuzzle returns { solvable: false } for unsolvable puzzles
- All public API exports available from src/engine/index.ts
- Integration test proves all modules work together
- No React/Firebase dependencies anywhere
</verification>

<success_criteria>
- BFS solver finds optimal solutions for solvable puzzles
- Solver correctly identifies unsolvable puzzles
- Full engine API exported from single barrel (types, board, engine, solver)
- Integration test proves end-to-end: parse -> play -> solve on same puzzle
- All Phase 1 success criteria from ROADMAP.md are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/01-game-engine/01-03-SUMMARY.md`
</output>
