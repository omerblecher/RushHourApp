---
phase: 04-firebase-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - .env.example
  - src/firebase.ts
  - src/store/authStore.ts
  - src/main.tsx
  - src/screens/AuthPromptScreen/AuthPromptScreen.tsx
  - src/screens/AuthPromptScreen/AuthPromptScreen.module.css
  - src/App.tsx
autonomous: false
requirements:
  - REQ-038
  - REQ-039
  - REQ-041

user_setup:
  - service: firebase
    why: "Firebase project must exist with Auth (Google + Anonymous providers) and Firestore (Native mode) enabled before the app can connect"
    env_vars:
      - name: VITE_FIREBASE_API_KEY
        source: "Firebase Console -> Project Settings -> Your apps -> Web app -> SDK snippet"
      - name: VITE_FIREBASE_AUTH_DOMAIN
        source: "Firebase Console -> Project Settings -> Your apps -> Web app -> SDK snippet"
      - name: VITE_FIREBASE_PROJECT_ID
        source: "Firebase Console -> Project Settings -> Your apps -> Web app -> SDK snippet"
      - name: VITE_FIREBASE_STORAGE_BUCKET
        source: "Firebase Console -> Project Settings -> Your apps -> Web app -> SDK snippet"
      - name: VITE_FIREBASE_MESSAGING_SENDER_ID
        source: "Firebase Console -> Project Settings -> Your apps -> Web app -> SDK snippet"
      - name: VITE_FIREBASE_APP_ID
        source: "Firebase Console -> Project Settings -> Your apps -> Web app -> SDK snippet"
    dashboard_config:
      - task: "Create Firebase project"
        location: "https://console.firebase.google.com -> Add project"
      - task: "Enable Google sign-in provider"
        location: "Firebase Console -> Authentication -> Sign-in method -> Google -> Enable"
      - task: "Enable Anonymous sign-in provider"
        location: "Firebase Console -> Authentication -> Sign-in method -> Anonymous -> Enable"
      - task: "Create Firestore database in Native mode"
        location: "Firebase Console -> Firestore Database -> Create database -> Start in production mode -> choose region"
      - task: "Register web app to get SDK config"
        location: "Firebase Console -> Project Settings -> Your apps -> Add app -> Web -> Register"

must_haves:
  truths:
    - "App launch shows a blocking auth prompt — user must choose Google or Anonymous before any game screen appears"
    - "Clicking 'Sign in with Google' opens a Google sign-in popup and logs the user in"
    - "Clicking 'Play anonymously' signs the user in as an anonymous Firebase user"
    - "After either choice, the normal app routing (MainMenu -> Puzzles -> Game) is accessible"
    - "Auth state survives page refresh — returning Google users skip the prompt; returning anon users also skip it"
  artifacts:
    - path: "src/firebase.ts"
      provides: "auth and db singletons with HMR guard"
      contains: "getApps().length ? getApp() : initializeApp"
    - path: "src/store/authStore.ts"
      provides: "Zustand auth store driven by onAuthStateChanged"
      exports: ["useAuthStore"]
    - path: "src/screens/AuthPromptScreen/AuthPromptScreen.tsx"
      provides: "Blocking launch UI with Google and anonymous sign-in options"
      min_lines: 30
    - path: "src/App.tsx"
      provides: "Auth gate — shows spinner, then AuthPromptScreen, then Routes"
  key_links:
    - from: "src/main.tsx"
      to: "src/store/authStore.ts"
      via: "useAuthStore.getState().initAuth() called before first render"
      pattern: "initAuth"
    - from: "src/App.tsx"
      to: "src/store/authStore.ts"
      via: "useAuthStore() — branches on isLoading and user"
      pattern: "isLoading|user.*null.*AuthPromptScreen"
    - from: "src/screens/AuthPromptScreen/AuthPromptScreen.tsx"
      to: "firebase/auth"
      via: "signInWithPopup + GoogleAuthProvider for Google; signInAnonymously for anonymous"
      pattern: "signInWithPopup|signInAnonymously"
---

<objective>
Install Firebase SDK, create the singleton init module, wire Zustand auth store to onAuthStateChanged, and build the blocking AuthPromptScreen that gates the entire app.

Purpose: Every subsequent Firebase plan depends on `auth` and `db` singletons existing. The auth gate is the first user-visible change — app launch now requires identity before any game screen renders.

Output: Firebase installed, `src/firebase.ts` with HMR-safe init, `src/store/authStore.ts` subscribed to auth changes, `AuthPromptScreen` with Google + Anonymous options, and `App.tsx` gating routes behind auth state.
</objective>

<execution_context>
@C:/Users/omerb/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omerb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-firebase-integration/04-CONTEXT.md
@.planning/phases/04-firebase-integration/04-RESEARCH.md
@src/App.tsx
@src/main.tsx
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 1: Firebase project setup and .env configuration</name>
  <action>Human must create a Firebase project, enable Google + Anonymous auth providers, create a Firestore database, register a web app, and populate the `.env` file with the real SDK config values. Claude cannot access the Firebase Console or create credentials.</action>
  <what-built>
    Before code runs, a Firebase project must exist with correct providers and a .env file in the repo root. This is the only task Claude cannot automate — it requires browser-based Firebase Console interaction and access to the generated config values.
  </what-built>
  <how-to-verify>
    1. Go to https://console.firebase.google.com and create (or select) the project for this app.
    2. In Authentication -> Sign-in method: enable Google and Anonymous providers.
    3. In Firestore Database: create database in Native mode (choose your region).
    4. In Project Settings -> Your apps: register a Web app, copy the SDK config object.
    5. Create `.env` at the repo root (NOT committed — already in .gitignore) with:
       ```
       VITE_FIREBASE_API_KEY=your_value
       VITE_FIREBASE_AUTH_DOMAIN=your_value
       VITE_FIREBASE_PROJECT_ID=your_value
       VITE_FIREBASE_STORAGE_BUCKET=your_value
       VITE_FIREBASE_MESSAGING_SENDER_ID=your_value
       VITE_FIREBASE_APP_ID=your_value
       ```
    6. Confirm `.env` exists and all six VITE_FIREBASE_* keys are populated with real values from the console.
  </how-to-verify>
  <resume-signal>Type "firebase ready" when the .env file is created with real values, or describe any issues</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Install Firebase SDK and create firebase.ts init module</name>
  <files>
    package.json
    .env.example
    src/firebase.ts
  </files>
  <action>
    Run: `npm install firebase`

    Create `.env.example` (committed, safe — no real values):
    ```
    VITE_FIREBASE_API_KEY=
    VITE_FIREBASE_AUTH_DOMAIN=
    VITE_FIREBASE_PROJECT_ID=
    VITE_FIREBASE_STORAGE_BUCKET=
    VITE_FIREBASE_MESSAGING_SENDER_ID=
    VITE_FIREBASE_APP_ID=
    ```

    Create `src/firebase.ts` using the HMR-safe guard pattern (prevents "Firebase App already exists" errors during Vite hot reload):
    ```typescript
    import { initializeApp, getApps, getApp } from 'firebase/app';
    import { getAuth } from 'firebase/auth';
    import { getFirestore } from 'firebase/firestore';

    const firebaseConfig = {
      apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
      authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
      projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
      storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
      messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
      appId: import.meta.env.VITE_FIREBASE_APP_ID,
    };

    // Guard against Vite HMR re-initialization
    const app = getApps().length ? getApp() : initializeApp(firebaseConfig);
    export const auth = getAuth(app);
    export const db = getFirestore(app);
    ```

    IMPORTANT: Do NOT use `import firebase from 'firebase/app'` (namespaced API, deprecated). Use only modular imports from subpaths.
  </action>
  <verify>
    `npm run typecheck` passes with no errors on `src/firebase.ts`.
    Confirm `package.json` lists `firebase` in `dependencies` (not devDependencies).
  </verify>
  <done>
    `src/firebase.ts` exports `auth` and `db` singletons. TypeScript compiles without errors. `.env.example` committed with empty placeholders.
  </done>
</task>

<task type="auto">
  <name>Task 3: Auth store + AuthPromptScreen + App.tsx auth gate</name>
  <files>
    src/store/authStore.ts
    src/main.tsx
    src/screens/AuthPromptScreen/AuthPromptScreen.tsx
    src/screens/AuthPromptScreen/AuthPromptScreen.module.css
    src/App.tsx
  </files>
  <action>
    Create `src/store/authStore.ts` — Zustand store subscribed to Firebase auth state. Do NOT use `persist` middleware — Firebase SDK handles its own auth persistence in IndexedDB. Store only the User object reference in memory:

    ```typescript
    import { create } from 'zustand';
    import { onAuthStateChanged, signInWithPopup, signInAnonymously, GoogleAuthProvider } from 'firebase/auth';
    import type { User } from 'firebase/auth';
    import { auth } from '../firebase';

    const googleProvider = new GoogleAuthProvider();

    interface AuthStore {
      user: User | null;
      isLoading: boolean;
      initAuth: () => () => void;
      signInWithGoogle: () => Promise<void>;
      signInAsGuest: () => Promise<void>;
    }

    export const useAuthStore = create<AuthStore>((set) => ({
      user: null,
      isLoading: true,

      initAuth: () => {
        return onAuthStateChanged(auth, (user) => {
          set({ user, isLoading: false });
        });
      },

      signInWithGoogle: async () => {
        await signInWithPopup(auth, googleProvider);
        // onAuthStateChanged will update the store automatically
      },

      signInAsGuest: async () => {
        await signInAnonymously(auth);
      },
    }));
    ```

    Modify `src/main.tsx` to call `initAuth()` before first render:
    ```typescript
    import { createRoot } from 'react-dom/client';
    import { BrowserRouter } from 'react-router';
    import App from './App';
    import { useAuthStore } from './store/authStore';
    import './index.css';

    // Subscribe to Firebase auth state before first render
    useAuthStore.getState().initAuth();

    const rootElement = document.getElementById('root');
    if (!rootElement) throw new Error('Root element not found');

    createRoot(rootElement).render(
      <BrowserRouter>
        <App />
      </BrowserRouter>
    );
    ```

    Create `src/screens/AuthPromptScreen/AuthPromptScreen.tsx` — blocking launch UI. Per CONTEXT.md decision, user MUST choose before playing:
    - Large card layout with game title
    - "Sign in with Google" primary button (Google icon text "G" + label)
    - "Play anonymously" secondary button with subtle note: "Anonymous scores won't appear on leaderboards"
    - Loading state during sign-in (disable buttons, show spinner text)
    - Error state: if popup blocked or fails, show brief error message below buttons (auto-clears after 3s)
    - Use CSS Module for styling consistent with existing app dark theme

    Create `src/screens/AuthPromptScreen/AuthPromptScreen.module.css` — centered card, dark background matching app theme, primary button with Google red-ish accent, secondary button muted. Match the font/color style of existing screens (see MainMenuScreen.module.css patterns if needed for consistency).

    Modify `src/App.tsx` to gate routes behind auth state:
    ```typescript
    import { Routes, Route } from 'react-router';
    import { useAuthStore } from './store/authStore';
    import { AuthPromptScreen } from './screens/AuthPromptScreen/AuthPromptScreen';
    // ... existing screen imports ...

    function App() {
      const { user, isLoading } = useAuthStore();

      if (isLoading) {
        return (
          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100dvh' }}>
            <p style={{ color: '#c8a96e', fontFamily: 'inherit' }}>Loading...</p>
          </div>
        );
      }

      if (!user) {
        return <AuthPromptScreen />;
      }

      return (
        <div className={styles.app}>
          <Routes>
            <Route path="/" element={<MainMenuScreen />} />
            <Route path="/puzzles" element={<PuzzleSelectScreen />} />
            <Route path="/play/:difficulty/:puzzleId" element={<GameScreen />} />
            <Route path="/leaderboard/:difficulty/:puzzleId" element={<LeaderboardScreen />} />
          </Routes>
        </div>
      );
    }
    ```

    CRITICAL: The loading spinner must show while `isLoading === true` so returning authenticated users do NOT see AuthPromptScreen briefly (Pitfall 2 from RESEARCH.md).
  </action>
  <verify>
    `npm run typecheck` passes.
    `npm run dev` starts without console errors.
    Visiting the app shows the auth prompt (not the main menu) when not signed in.
    After clicking "Play anonymously", the main menu appears.
    After page refresh with anonymous session active, the main menu appears directly (no re-prompt).
  </verify>
  <done>
    App launch shows AuthPromptScreen. Both sign-in paths work. Auth state persists across refresh. isLoading spinner prevents prompt flash for returning users.
  </done>
</task>

</tasks>

<verification>
Run `npm run typecheck` — zero TypeScript errors.
Run `npm run dev` — app launches, auth prompt appears, both sign-in options work, routing works after auth.
Auth persistence: refresh page after anonymous sign-in → main menu appears directly.
</verification>

<success_criteria>
- Firebase SDK installed and importable
- `src/firebase.ts` exports `auth` + `db` with HMR guard
- `src/store/authStore.ts` subscribes to auth state via onAuthStateChanged
- AuthPromptScreen blocks app until user chooses Google or Anonymous
- App.tsx gates routes: spinner → AuthPromptScreen → Routes
- All TypeScript checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-firebase-integration/04-01-SUMMARY.md` with:
- What was built (firebase.ts, authStore, AuthPromptScreen, App.tsx gate)
- Patterns established (HMR guard, initAuth in main.tsx, isLoading gate)
- Any deviations from plan
- Exact file list with brief description
</output>
