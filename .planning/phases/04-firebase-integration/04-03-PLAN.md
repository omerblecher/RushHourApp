---
phase: 04-firebase-integration
plan: 03
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - src/hooks/useLeaderboard.ts
  - src/components/LeaderboardModal/LeaderboardModal.tsx
  - src/components/LeaderboardModal/LeaderboardModal.module.css
autonomous: true
requirements:
  - REQ-042
  - REQ-043

must_haves:
  truths:
    - "useLeaderboard hook fetches top 50 scores for a puzzleId sorted by moves asc then timeMs asc"
    - "If the current user is in the top 50, their row is highlighted"
    - "If the current user is outside the top 50, a pinned 'Your best' row appears below the list"
    - "LeaderboardModal renders a modal overlay with rank, display name, moves, and time columns"
    - "LeaderboardModal shows a loading skeleton while data fetches"
    - "Anonymous users see a prompt to sign in instead of the leaderboard table"
  artifacts:
    - path: "src/hooks/useLeaderboard.ts"
      provides: "Firestore query for top 50 scores + current user's score if outside top 50"
      exports: ["useLeaderboard", "LeaderboardEntry"]
    - path: "src/components/LeaderboardModal/LeaderboardModal.tsx"
      provides: "Modal overlay displaying leaderboard entries with user highlighting and anonymous gate"
      exports: ["LeaderboardModal"]
    - path: "src/components/LeaderboardModal/LeaderboardModal.module.css"
      provides: "Modal styles matching app dark theme"
  key_links:
    - from: "src/components/LeaderboardModal/LeaderboardModal.tsx"
      to: "src/hooks/useLeaderboard.ts"
      via: "useLeaderboard(puzzleId) called inside modal"
      pattern: "useLeaderboard"
    - from: "src/hooks/useLeaderboard.ts"
      to: "src/firebase.ts"
      via: "collection(db, 'puzzles', puzzleId, 'scores') + getDocs"
      pattern: "getDocs|collection.*puzzles"
---

<objective>
Build the leaderboard data hook and the reusable LeaderboardModal component. These are consumed by both the WinModal (plan 04-04) and the PuzzleSelectScreen (plan 04-04).

Purpose: Decoupled from game integration so both consuming screens can use the same component. The modal handles its own data fetching via the hook.

Output: `useLeaderboard.ts` fetching Firestore top-50 scores, `LeaderboardModal.tsx` rendering rank/name/moves/time table with user highlighting, pinned out-of-top-50 row, loading skeleton, and anonymous sign-in gate.
</objective>

<execution_context>
@C:/Users/omerb/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omerb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-firebase-integration/04-CONTEXT.md
@.planning/phases/04-firebase-integration/04-RESEARCH.md
@src/firebase.ts
@src/store/authStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: useLeaderboard hook</name>
  <files>
    src/hooks/useLeaderboard.ts
  </files>
  <action>
    Create `src/hooks/useLeaderboard.ts`.

    Export `LeaderboardEntry` interface:
    ```typescript
    export interface LeaderboardEntry {
      uid: string;
      rank: number;        // 1-based rank within top 50; -1 for pinned user entry outside top 50
      displayName: string;
      moves: number;
      timeMs: number;
    }
    ```

    Export `useLeaderboard(puzzleId: string)` hook returning `{ entries: LeaderboardEntry[], userEntry: LeaderboardEntry | null, isLoading: boolean }`.

    Implementation:
    - On mount (and when puzzleId changes), fetch via `getDocs` (NOT `onSnapshot` — one-time read is sufficient and cheaper):
      ```
      query(collection(db, 'puzzles', puzzleId, 'scores'), orderBy('moves', 'asc'), orderBy('timeMs', 'asc'), limit(50))
      ```
    - Map snapshot docs to `LeaderboardEntry[]` with rank = index + 1
    - Get current user from `auth.currentUser`
    - If user is non-anonymous: check if they appear in top50 (by uid)
      - If NOT in top 50: fetch their own score doc with `getDoc(doc(db, 'puzzles', puzzleId, 'scores', uid))`
        - If it exists: set `userEntry = { uid, rank: -1, ...doc.data() }` (rank -1 = "outside top 50")
        - If it doesn't exist: `userEntry = null` (user has no score yet)
    - If user is anonymous or null: `userEntry = null` (anon users don't participate)
    - Set `isLoading = false` after both fetches complete
    - Handle errors silently (catch, set empty arrays, isLoading: false)

    Use `useEffect` with `[puzzleId]` dependency. Reset `isLoading: true` when puzzleId changes.

    IMPORTANT: The composite orderBy requires the Firestore composite index from plan 04-02. If the index isn't deployed yet, the query will fail silently (caught by error handler). This is fine during development.
  </action>
  <verify>
    `npm run typecheck` passes.
    Inspect `useLeaderboard.ts`: uses `getDocs` (not `onSnapshot`), has try/catch, handles the user-outside-top-50 case with a second `getDoc`.
  </verify>
  <done>
    `useLeaderboard` hook exported with correct return shape. TypeScript compiles. Handles anonymous users (returns null userEntry), missing index gracefully (returns empty entries), and outside-top-50 scenario.
  </done>
</task>

<task type="auto">
  <name>Task 2: LeaderboardModal component</name>
  <files>
    src/components/LeaderboardModal/LeaderboardModal.tsx
    src/components/LeaderboardModal/LeaderboardModal.module.css
  </files>
  <action>
    Create `src/components/LeaderboardModal/LeaderboardModal.tsx`.

    Props:
    ```typescript
    interface LeaderboardModalProps {
      puzzleId: string;
      onClose: () => void;
      onSignInToCompete?: () => void;  // called when anon user clicks "Sign in to compete"
    }
    ```

    Inside the modal, call `useLeaderboard(puzzleId)` to get data.
    Get `user` from `useAuthStore()`.

    Render logic:
    1. Backdrop + card (same pattern as WinModal — `role="dialog"`, `aria-modal="true"`)
    2. Header: "Leaderboard" title + "×" close button
    3. If `isLoading`: show loading skeleton (3-5 skeleton rows with pulsing CSS animation)
    4. If user is anonymous (`user?.isAnonymous === true`): show anonymous gate instead of table:
       - Message: "Sign in to compete on the global leaderboard"
       - "Sign in with Google" button (calls `onSignInToCompete`)
       - Below the gate, still show the leaderboard table if there are entries (anonymous users can read the leaderboard, just can't submit)
    5. Leaderboard table with 4 columns: Rank | Name | Moves | Time
       - Format time with `formatTime(ms)` helper (M:SS format, same as WinModal)
       - For rank column: show "1", "2", "#50" etc. For `rank === -1` (pinned): show "—"
       - Highlight the current user's row: apply `.userRow` CSS class when `entry.uid === user?.uid`
       - If `userEntry` exists (user outside top 50): render a visual separator (`...`) then the pinned row below the table with label "Your best"
       - If no entries (fresh leaderboard / index not deployed): show "No scores yet — be the first!"
    6. Close button at bottom

    Create `src/components/LeaderboardModal/LeaderboardModal.module.css`:
    - Match the dark wood/amber theme of the existing app (see WinModal.module.css for reference)
    - Backdrop: fixed overlay, semi-transparent dark background
    - Card: max-width 480px, centered, scrollable if tall
    - Table: full width, alternating row shading, border separators
    - `.userRow`: distinct background (amber/gold highlight) + bold text to identify current user
    - Skeleton rows: grey placeholder bars with CSS `@keyframes pulse` animation
    - Separator: `...` styled in muted color between top-50 and pinned row
    - Pinned row: slightly different background to distinguish from ranked entries

    Helper `formatTime` — copy from WinModal or extract to `src/utils/formatTime.ts` if that file doesn't already exist. Check first; avoid duplication.
  </action>
  <verify>
    `npm run typecheck` passes.
    Inspect component: has loading state, has anonymous gate, has user row highlighting, has pinned out-of-top-50 entry, uses `useLeaderboard` hook.
  </verify>
  <done>
    `LeaderboardModal` exported. Shows loading skeleton, anonymous gate with sign-in prompt, ranked table with user highlighting, and pinned "Your best" row for users outside top 50. TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
`npm run typecheck` — zero errors.
Inspect hook: `getDocs` with compound orderBy + limit(50), plus second `getDoc` for out-of-top-50 user.
Inspect modal: handles all three states (loading, data, anonymous-gate) + user row highlighting.
</verification>

<success_criteria>
- `useLeaderboard` fetches top-50 entries ranked by moves then timeMs
- User's own entry pinned at bottom if outside top 50 (rank: -1, no rank number shown)
- `LeaderboardModal` renders loading skeleton, anonymous gate, ranked table, user highlighting
- Both files compile with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-firebase-integration/04-03-SUMMARY.md` with:
- Hook return shape and loading/error behavior
- Modal rendering states
- Any deviations from plan
</output>
