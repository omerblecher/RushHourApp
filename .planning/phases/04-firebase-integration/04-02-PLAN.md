---
phase: 04-firebase-integration
plan: 02
type: execute
wave: 2
depends_on:
  - 04-01
files_modified:
  - firestore.rules
  - firestore.indexes.json
  - src/services/scoreService.ts
autonomous: true
requirements:
  - REQ-044
  - REQ-045
  - REQ-046
  - NFR-006

must_haves:
  truths:
    - "Firestore security rules prevent anonymous users from writing scores"
    - "Security rules reject scores where moves < minMoves (server-side validation)"
    - "Security rules reject score writes that are not improvements over the existing best"
    - "Only the user's own score document can be written (userId == auth.uid enforced)"
    - "submitScore() runs silently — it never throws or surfaces errors to the caller"
    - "mergeAnonymousScores() copies anonymous scores to a Google account when better"
  artifacts:
    - path: "firestore.rules"
      provides: "Firestore security rules enforcing auth, ownership, move validation, and improvement-only writes"
      contains: "sign_in_provider != 'anonymous'"
    - path: "firestore.indexes.json"
      provides: "Composite index for leaderboard orderBy(moves, asc).orderBy(timeMs, asc)"
      contains: "moves"
    - path: "src/services/scoreService.ts"
      provides: "submitScore(), mergeAnonymousScores(), getUserDisplayName(), setDisplayName(), updateScoreDisplayNames()"
      exports: ["submitScore", "mergeAnonymousScores", "getUserDisplayName", "setDisplayName", "isDisplayNameAvailable"]
  key_links:
    - from: "src/services/scoreService.ts"
      to: "firestore.rules"
      via: "setDoc on puzzles/{puzzleId}/scores/{uid} — rule enforces improvement + minMoves"
      pattern: "setDoc.*scores"
    - from: "src/services/scoreService.ts"
      to: "src/firebase.ts"
      via: "imports auth and db singletons"
      pattern: "import.*from.*firebase"
---

<objective>
Write the Firestore security rules, composite index definition, and the score/display-name service layer. This plan establishes the server-side integrity backbone and the client-side service functions that the game integration plan (04-04) will call.

Purpose: Rules are the only un-bypassable enforcement layer. Score service encapsulates all Firestore write logic behind clean functions so game components stay thin.

Output: `firestore.rules` enforcing all data integrity requirements, `firestore.indexes.json` for the leaderboard compound query, and `src/services/scoreService.ts` with submitScore, mergeAnonymousScores, and display name management functions.
</objective>

<execution_context>
@C:/Users/omerb/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omerb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-firebase-integration/04-RESEARCH.md
@src/firebase.ts
@src/store/authStore.ts
@src/store/progressStore.ts
@src/data/puzzleIndex.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Firestore security rules and composite index</name>
  <files>
    firestore.rules
    firestore.indexes.json
  </files>
  <action>
    Create `firestore.rules` at the project root. Implement all rules from RESEARCH.md:

    ```
    rules_version = '2';
    service cloud.firestore {
      match /databases/{database}/documents {

        // ---- Users ----
        match /users/{uid} {
          allow read: if request.auth != null;
          allow create: if request.auth.uid == uid;
          allow update: if request.auth.uid == uid;
        }

        // ---- Usernames (uniqueness enforcement) ----
        match /usernames/{displayName} {
          allow read: if request.auth != null;
          // Batch write: usernames doc + users doc must be committed atomically.
          // getAfter verifies the users/{uid}.displayName matches this username key.
          allow write: if request.auth != null
            && request.resource.data.uid == request.auth.uid
            && getAfter(/databases/$(database)/documents/users/$(request.auth.uid)).data.displayName == displayName;
        }

        // ---- Leaderboard Scores ----
        match /puzzles/{puzzleId}/scores/{uid} {
          // Public read — leaderboard is visible to all
          allow read: if true;

          // Write rules (REQ-044, REQ-045, REQ-046, NFR-006):
          allow write: if
            // Must be authenticated and non-anonymous
            request.auth != null &&
            request.auth.token.firebase.sign_in_provider != 'anonymous' &&
            // Must be writing own score
            request.auth.uid == uid &&
            request.resource.data.userId == request.auth.uid &&
            // Required fields with correct types
            request.resource.data.moves is int &&
            request.resource.data.timeMs is int &&
            request.resource.data.minMoves is int &&
            // Server-side move count validation (REQ-046)
            request.resource.data.moves >= request.resource.data.minMoves &&
            // Only allow if: first score OR improvement (REQ-044, REQ-045)
            (
              !exists(/databases/$(database)/documents/puzzles/$(puzzleId)/scores/$(uid)) ||
              request.resource.data.moves < resource.data.moves ||
              (request.resource.data.moves == resource.data.moves &&
               request.resource.data.timeMs < resource.data.timeMs)
            );
        }
      }
    }
    ```

    Create `firestore.indexes.json` at the project root for the leaderboard compound query:
    ```json
    {
      "indexes": [
        {
          "collectionGroup": "scores",
          "queryScope": "COLLECTION",
          "fields": [
            { "fieldPath": "moves", "order": "ASCENDING" },
            { "fieldPath": "timeMs", "order": "ASCENDING" }
          ]
        }
      ],
      "fieldOverrides": []
    }
    ```

    NOTE: These files are deployed to Firebase via `firebase deploy --only firestore` (using firebase-tools CLI), but the executor does not need to run that command now — it will be done during human verification.
  </action>
  <verify>
    Files exist at `firestore.rules` and `firestore.indexes.json` in the project root.
    `firestore.rules` contains `sign_in_provider != 'anonymous'` (anon block) and `moves >= request.resource.data.minMoves` (server validation).
    `firestore.indexes.json` contains the `scores` collectionGroup index on `moves` and `timeMs`.
  </verify>
  <done>
    Both files exist with correct content. Security rules cover: auth required, non-anonymous, ownership, type checks, minMoves validation, improvement-only writes. Index covers leaderboard compound sort.
  </done>
</task>

<task type="auto">
  <name>Task 2: Score service and display name service</name>
  <files>
    src/services/scoreService.ts
  </files>
  <action>
    Create `src/services/scoreService.ts`. This file owns all Firestore write operations for scores and display names. Key behaviors:

    1. `submitScore(puzzleId, moves, timeMs, minMoves)`:
       - Returns void, never throws (silent failure per CONTEXT.md)
       - No-op if user is null or anonymous
       - Reads displayName from `users/{uid}` doc (falls back to Google displayName from auth token, then "Player" as last resort)
       - Writes to `puzzles/{puzzleId}/scores/{uid}` via setDoc — the security rule rejects non-improvements, client swallows that rejection silently
       - Score doc shape: `{ userId, displayName, moves, timeMs, minMoves, solvedAt: Date.now() }`

    2. `getUserDisplayName(uid)`: Reads from `users/{uid}.displayName`, falls back to `auth.currentUser.displayName`, then `"Player"`.

    3. `isDisplayNameAvailable(name)`: Checks `usernames/{name.toLowerCase()}` exists. Returns boolean.

    4. `setDisplayName(newName)`:
       - Validates: must be 2-20 chars (Claude's discretion for limits), non-empty after trim
       - Normalizes: trim whitespace
       - Checks availability via getDoc on `usernames/{normalized.toLowerCase()}`
       - Uses writeBatch: atomically sets `users/{uid}.displayName` and `usernames/{lowercase}` -> `{uid}`
       - Returns `'ok' | 'taken' | 'invalid'`
       - Also triggers `updateScoreDisplayNames` as best-effort background update

    5. `updateScoreDisplayNames(uid, displayName)`:
       - After a name change, updates the user's score docs across all puzzles
       - Strategy: read ALL_PUZZLES from puzzleIndex, check if a score doc exists for each puzzleId, batch-update those that do
       - Best-effort: errors are silently swallowed (eventual consistency is acceptable)
       - Limit batch to 500 writes max (Firestore limit); with 100 puzzles this is fine

    6. `mergeAnonymousScores(anonUid, googleUid)`:
       - Called during the anonymous-to-Google credential-already-in-use merge path
       - For each puzzle in ALL_PUZZLES, check if anonUid has a score
       - For puzzles where anonUid has a score, check if googleUid's score is worse (or missing)
       - If anonUid's score is better: write it to googleUid's score doc
       - Best-effort: errors silently swallowed

    Import `ALL_PUZZLES` from `'../data/puzzleIndex'` for the puzzle list iteration.

    TypeScript: define `interface ScoreDoc` with the score shape. Export `submitScore`, `mergeAnonymousScores`, `getUserDisplayName`, `setDisplayName`, `isDisplayNameAvailable`, `updateScoreDisplayNames`.

    CRITICAL: The security rule only accepts writes where `moves >= minMoves`. Always include `minMoves` in the score doc. Never omit it.
  </action>
  <verify>
    `npm run typecheck` passes.
    Inspect `scoreService.ts`: `submitScore` has a try/catch that swallows errors. `mergeAnonymousScores` exists and iterates ALL_PUZZLES. `setDisplayName` uses `writeBatch` (not two separate writes).
  </verify>
  <done>
    `src/services/scoreService.ts` exports all required functions. TypeScript compiles cleanly. Score submission is silent. Display name management uses batch writes for atomicity. Anonymous score merge iterates all puzzles.
  </done>
</task>

</tasks>

<verification>
`npm run typecheck` — zero errors.
`firestore.rules` syntactically valid (no obvious parse errors when read).
`scoreService.ts` compiles and exports the expected functions.
</verification>

<success_criteria>
- `firestore.rules` enforces all data integrity requirements (auth, non-anon, ownership, minMoves, improvement-only)
- `firestore.indexes.json` defines composite index for leaderboard query
- `submitScore()` is silent, includes minMoves, no-ops for anonymous
- `setDisplayName()` uses batch write for atomicity, returns 'ok'|'taken'|'invalid'
- `mergeAnonymousScores()` does best-effort copy of better scores from anonUid to googleUid
- TypeScript compiles with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-firebase-integration/04-02-SUMMARY.md` with:
- What was built (rules, indexes, scoreService)
- Key function signatures
- Any deviations from plan
</output>
