---
phase: 03-puzzle-data-and-navigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - vite.config.ts
  - scripts/validate-puzzles.ts
  - src/data/puzzles/beginner.json
  - src/data/puzzles/intermediate.json
  - src/data/puzzles/advanced.json
  - src/data/puzzles/expert.json
  - src/data/puzzleIndex.ts
  - src/store/progressStore.ts
autonomous: true
requirements:
  - REQ-025
  - REQ-026
  - REQ-027
  - REQ-031
  - REQ-032

must_haves:
  truths:
    - "80+ puzzles exist across 4 difficulty levels with 20+ per level"
    - "Every puzzle is validated as solvable with correct minMoves at build time"
    - "Player progress (completion, best moves, best time) persists in localStorage across page refreshes"
    - "Puzzles within each difficulty are ordered by complexity (easiest first)"
  artifacts:
    - path: "src/data/puzzles/beginner.json"
      provides: "20+ beginner puzzle definitions"
      contains: "beginner-01"
    - path: "src/data/puzzles/intermediate.json"
      provides: "20+ intermediate puzzle definitions"
      contains: "intermediate-01"
    - path: "src/data/puzzles/advanced.json"
      provides: "20+ advanced puzzle definitions"
      contains: "advanced-01"
    - path: "src/data/puzzles/expert.json"
      provides: "20+ expert puzzle definitions"
      contains: "expert-01"
    - path: "src/data/puzzleIndex.ts"
      provides: "Puzzle aggregation and lookup"
      exports: ["ALL_PUZZLES", "PUZZLES_BY_DIFFICULTY", "getPuzzleById"]
    - path: "src/store/progressStore.ts"
      provides: "localStorage-backed progress tracking"
      exports: ["useProgressStore"]
    - path: "scripts/validate-puzzles.ts"
      provides: "Build-time puzzle validation"
  key_links:
    - from: "src/data/puzzleIndex.ts"
      to: "src/data/puzzles/*.json"
      via: "static imports"
      pattern: "import.*from.*puzzles/"
    - from: "scripts/validate-puzzles.ts"
      to: "src/engine/solver.ts"
      via: "solvePuzzle import"
      pattern: "solvePuzzle"
    - from: "src/store/progressStore.ts"
      to: "localStorage"
      via: "Zustand persist middleware"
      pattern: "persist.*rushhour_progress"
---

<objective>
Create the puzzle data pipeline and progress persistence layer for Phase 3.

Purpose: Provide the 80+ validated puzzle definitions that the UI screens will consume, and the localStorage-backed store that tracks player completion and personal bests.

Output: 4 JSON puzzle files (20+ per difficulty), a puzzleIndex module for lookups, a build-time validation script, and a Zustand progress store with persist middleware.
</objective>

<execution_context>
@C:/Users/omerb/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omerb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/engine/types.ts
@src/engine/solver.ts
@src/engine/board.ts
@src/engine/index.ts
@package.json
@vite.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create 80+ puzzle definitions and build-time validation</name>
  <files>
    package.json
    scripts/validate-puzzles.ts
    src/data/puzzles/beginner.json
    src/data/puzzles/intermediate.json
    src/data/puzzles/advanced.json
    src/data/puzzles/expert.json
    src/data/puzzleIndex.ts
  </files>
  <action>
Install `tsx` as devDependency (`npm install -D tsx`) and `react-router` as dependency (`npm install react-router`) — combine both installs now so Plan 02 doesn't need to touch package.json.

**Puzzle data creation (Claude's discretion area):**

Source puzzles from the Fogleman rush1000.txt dataset or hand-author 80+ valid Rush Hour grid strings. Each puzzle is a 36-character string using `.` for empty, `X` for the red target car (horizontal on row 2), and uppercase letters for other vehicles.

Create 4 JSON files matching the `PuzzleDefinition` type from `src/engine/types.ts`:
```json
[
  { "id": "beginner-01", "gridString": "...36chars...", "difficulty": "beginner", "minMoves": N }
]
```

**Difficulty classification (user decision: based on vehicle count + congestion, not just minMoves):**
- Beginner: simpler boards, fewer vehicles (≤8), lower minMoves (6-11). 20+ puzzles.
- Intermediate: moderate boards, 8-11 vehicles, minMoves 11-17. 20+ puzzles.
- Advanced: complex boards, 10-13 vehicles, minMoves 17-25. 20+ puzzles.
- Expert: very complex boards, 13+ vehicles or minMoves 25+. 20+ puzzles.

Order puzzles within each difficulty by complexity (easiest first, gradual ramp).

ID format: `{difficulty}-{NN}` (e.g., `beginner-01`, `expert-20`). Zero-padded two digits.

**puzzleIndex.ts:**
Create `src/data/puzzleIndex.ts` that:
- Imports all 4 JSON files
- Exports `ALL_PUZZLES: PuzzleDefinition[]` (all puzzles concatenated)
- Exports `PUZZLES_BY_DIFFICULTY: Record<Difficulty, PuzzleDefinition[]>` (grouped by difficulty)
- Exports `getPuzzleById(id: string): PuzzleDefinition | undefined` (lookup by ID)
- Exports `getNextPuzzle(currentId: string): PuzzleDefinition | undefined` (next puzzle in same difficulty, for "Next Puzzle" button)

**Validation script:**
Create `scripts/validate-puzzles.ts` that:
- Imports `solvePuzzle` from `../src/engine/solver`
- Imports all 4 JSON files
- For each puzzle: calls `solvePuzzle(gridString)`, asserts solvable, asserts `minMoves` matches declared value
- Prints summary (total count, per-difficulty count)
- Exits with code 1 if any puzzle fails

Add to `package.json` scripts:
```json
"validate-puzzles": "tsx scripts/validate-puzzles.ts",
"prebuild": "npm run validate-puzzles"
```

**IMPORTANT:** Every gridString MUST be exactly 36 characters. `X` MUST appear on row 2 (characters 12-17) as a horizontal 2-cell vehicle. Run the validation script after creating puzzles to confirm all pass.

**Strategy for creating valid puzzles:**
The easiest approach is to generate puzzles programmatically using a puzzle generator script, or to use known valid Rush Hour configurations from online sources (ThinkFun original puzzles, community databases). Each puzzle MUST pass the BFS solver. If hand-authoring, test each one incrementally.

Alternatively, fetch the Fogleman dataset from https://www.michaelfogleman.com/rush/ and convert. The Fogleman format uses a different letter convention — the target car may not be `X`. Write a conversion that:
1. Identifies the horizontal vehicle on row 2 as the target car
2. Renames it to `X` in the grid string
3. Preserves all other vehicle letters
4. Extracts the move count as minMoves

Whichever approach, the end result is 4 JSON files with 20+ puzzles each, all passing validation.
  </action>
  <verify>
Run `npm run validate-puzzles` — must print "All N puzzles valid" with N >= 80 and exit 0. Verify each difficulty has 20+ puzzles. Run `npx tsc --noEmit` to confirm puzzleIndex.ts type-checks.
  </verify>
  <done>
4 JSON files exist with 80+ total puzzles (20+ per difficulty). Validation script passes. puzzleIndex exports work. IDs follow `{difficulty}-{NN}` format. Puzzles ordered by complexity within each difficulty.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create localStorage progress store with Zustand persist</name>
  <files>
    src/store/progressStore.ts
  </files>
  <action>
Create `src/store/progressStore.ts` using Zustand with `persist` middleware.

**Store shape:**
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export interface PuzzleProgress {
  completedAt: number;  // Date.now() timestamp
  bestMoves: number;
  bestTimeMs: number;
}

interface ProgressStore {
  progress: Record<string, PuzzleProgress>;  // key = puzzleId
  recordCompletion: (puzzleId: string, moves: number, timeMs: number) => void;
  isCompleted: (puzzleId: string) => boolean;
  getBest: (puzzleId: string) => PuzzleProgress | undefined;
}
```

**recordCompletion logic:**
- If no existing record for puzzleId: store the new completion
- If existing record: only update if new attempt is better (fewer moves, or same moves but faster time)
- Always update `completedAt` to the latest completion timestamp
- Use localStorage key `"rushhour_progress"`

**isCompleted:** Returns `true` if puzzleId exists in progress map.

**getBest:** Returns the PuzzleProgress record for a puzzleId, or undefined.

Use `persist` middleware from `zustand/middleware`. For localStorage (default storage), persist hydrates synchronously — no race condition concerns.
  </action>
  <verify>
Run `npx tsc --noEmit` — progressStore.ts type-checks with no errors.
  </verify>
  <done>
progressStore.ts exists with persist middleware, `recordCompletion` correctly handles best-score logic, `isCompleted` and `getBest` work as lookups. localStorage key is `"rushhour_progress"`.
  </done>
</task>

</tasks>

<verification>
1. `npm run validate-puzzles` exits 0 with 80+ puzzles validated
2. `npx tsc --noEmit` passes (all new files type-check)
3. Each difficulty JSON has 20+ entries
4. Puzzle IDs follow `{difficulty}-{NN}` convention
5. progressStore compiles and exports expected interface
</verification>

<success_criteria>
- 80+ validated solvable puzzles across 4 difficulties (20+ each)
- Build-time validation integrated into npm scripts (prebuild hook)
- puzzleIndex provides lookup by ID and by difficulty
- progressStore persists completion data to localStorage
- All TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-puzzle-data-and-navigation/03-01-SUMMARY.md`
</output>
