---
phase: 03-puzzle-data-and-navigation
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/ControlBar/ControlBar.tsx
  - src/components/ControlBar/ControlBar.module.css
  - .planning/REQUIREMENTS.md
autonomous: true
gap_closure: true
requirements:
  - REQ-032
  - REQ-051

must_haves:
  truths:
    - "Mute button appears in ControlBar alongside Undo, Reset, and Menu buttons"
    - "Clicking Mute toggles its visual state and persists the preference to localStorage under key 'rushhour_muted'"
    - "REQ-032 is documented as satisfied via WinModal (not puzzle tiles) per user's locked context decision"
  artifacts:
    - path: "src/components/ControlBar/ControlBar.tsx"
      provides: "Mute toggle button with localStorage persistence"
      contains: "rushhour_muted"
    - path: ".planning/REQUIREMENTS.md"
      provides: "Clarifying annotation on REQ-032"
      contains: "WinModal"
  key_links:
    - from: "src/components/ControlBar/ControlBar.tsx"
      to: "localStorage"
      via: "localStorage.setItem('rushhour_muted', ...)"
      pattern: "rushhour_muted"
---

<objective>
Close the two verification gaps identified in 03-VERIFICATION.md.

Gap 1 (REQ-032) is a false positive: the verifier flagged that personal best is not shown on puzzle tiles, but the user's locked CONTEXT.md decision explicitly states tiles show only completion status (checkmark). Personal best IS shown in the WinModal. No code change is needed â€” only an annotation to REQUIREMENTS.md to clarify REQ-032 is satisfied via WinModal per user decision.

Gap 2 (REQ-051) is real: REQ-051 requires game board controls of "reset, back, mute". Reset and back exist. A mute toggle stub is missing. This plan adds a functional mute button to ControlBar that persists preference to localStorage under key "rushhour_muted". Phase 5 audio implementation will read this key.

Purpose: Satisfy both gap requirements so Phase 3 verification passes cleanly.
Output: Updated ControlBar with mute toggle; annotated REQUIREMENTS.md.
</objective>

<execution_context>
@C:/Users/omerb/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omerb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@src/components/ControlBar/ControlBar.tsx
@src/components/ControlBar/ControlBar.module.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mute toggle stub to ControlBar</name>
  <files>
    src/components/ControlBar/ControlBar.tsx
    src/components/ControlBar/ControlBar.module.css
  </files>
  <action>
Update ControlBar.tsx to add a mute toggle button. The button:
- Reads initial state from localStorage.getItem('rushhour_muted') === 'true' on mount using a useState initializer (no useEffect needed)
- Toggles a local boolean state `isMuted`
- On toggle: writes the new value to localStorage.setItem('rushhour_muted', String(!isMuted)) and flips the state
- Shows icon "ðŸ”‡" when muted, "ðŸ”Š" when unmuted (or use text: "ðŸ”‡" / "ðŸ”Š")
- Label text: "Mute" when unmuted, "Unmute" when muted
- aria-label: "Mute sound" when unmuted, "Unmute sound" when muted
- aria-pressed={isMuted}
- Never disabled (unlike Undo/Reset which disable based on state)
- Uses the existing .button and .icon and .label CSS classes â€” no new class needed
- Position it as the fourth button, after Menu, or between Reset and Menu â€” match the visual order: Undo | Reset | Menu | Mute. Actually place it last for minimal diff: Undo | Reset | Menu | Mute.

The full updated component (preserve all existing imports and logic):

```tsx
import { useState } from 'react';
import { useNavigate } from 'react-router';
import { useGameStore } from '../../store/gameStore';
import styles from './ControlBar.module.css';

const MUTE_KEY = 'rushhour_muted';

export function ControlBar() {
  const navigate = useNavigate();
  const undo = useGameStore((s) => s.undo);
  const reset = useGameStore((s) => s.reset);
  const moveCount = useGameStore((s) => s.state?.moveCount ?? 0);
  const historyLength = useGameStore((s) => s.state?.moveHistory.length ?? 0);

  const [isMuted, setIsMuted] = useState<boolean>(
    () => localStorage.getItem(MUTE_KEY) === 'true'
  );

  const canUndo = historyLength > 0;
  const canReset = moveCount > 0;

  const handleMenu = () => {
    navigate(-1);
  };

  const handleMute = () => {
    const next = !isMuted;
    setIsMuted(next);
    localStorage.setItem(MUTE_KEY, String(next));
  };

  return (
    <div className={styles.controlBar} role="toolbar" aria-label="Game controls">
      <button
        className={styles.button}
        onClick={() => undo()}
        disabled={!canUndo}
        title="Undo last move"
        aria-label="Undo last move"
      >
        <span className={styles.icon} aria-hidden="true">â†©</span>
        <span className={styles.label}>Undo</span>
      </button>

      <button
        className={styles.button}
        onClick={() => reset()}
        disabled={!canReset}
        title="Reset puzzle"
        aria-label="Reset puzzle to initial state"
      >
        <span className={styles.icon} aria-hidden="true">â†º</span>
        <span className={styles.label}>Reset</span>
      </button>

      <button
        className={styles.button}
        onClick={handleMenu}
        title="Back to menu"
        aria-label="Back to menu"
      >
        <span className={styles.icon} aria-hidden="true">â˜°</span>
        <span className={styles.label}>Menu</span>
      </button>

      <button
        className={styles.button}
        onClick={handleMute}
        title={isMuted ? 'Unmute sound' : 'Mute sound'}
        aria-label={isMuted ? 'Unmute sound' : 'Mute sound'}
        aria-pressed={isMuted}
      >
        <span className={styles.icon} aria-hidden="true">{isMuted ? 'ðŸ”‡' : 'ðŸ”Š'}</span>
        <span className={styles.label}>{isMuted ? 'Unmute' : 'Mute'}</span>
      </button>
    </div>
  );
}
```

No CSS changes are needed â€” the mute button reuses the existing .button, .icon, and .label classes which already provide the correct visual treatment. The ControlBar.module.css file does NOT need to be modified.
  </action>
  <verify>
1. `npm run build` completes with no TypeScript errors
2. In the running dev server, navigate to any puzzle's game board â€” the ControlBar shows four buttons: Undo, Reset, Menu, Mute
3. Click Mute â€” the icon changes to ðŸ”‡ and label reads "Unmute"
4. Refresh the page â€” the mute button still shows ðŸ”‡ (localStorage persisted)
5. Click again â€” toggles back to ðŸ”Š "Mute"
6. In browser DevTools > Application > Local Storage â€” confirm key "rushhour_muted" exists with value "true" or "false"
  </verify>
  <done>Mute toggle button present in ControlBar, toggles icon/label on click, persists to localStorage under "rushhour_muted", and survives page refresh</done>
</task>

<task type="auto">
  <name>Task 2: Annotate REQUIREMENTS.md to close Gap 1 (REQ-032 false positive)</name>
  <files>
    .planning/REQUIREMENTS.md
  </files>
  <action>
Gap 1 in VERIFICATION.md flagged REQ-032 ("Personal best moves/time shown per puzzle") as not satisfied because getBest is never called in PuzzleTile. This is a false positive: the user's locked CONTEXT.md decision explicitly states puzzle tiles show only completion status (checkmark). Personal best IS shown in the WinModal ("Your Moves", "Minimum Moves", "Your Time" fields). No code change to PuzzleTile is warranted.

Update REQUIREMENTS.md to document this resolution:

1. In the Puzzles table, find REQ-032 row and add a note column or append inline annotation. The current row is:
   `| REQ-032 | Personal best moves/time shown per puzzle | SHOULD |`

   Change to:
   `| REQ-032 | Personal best moves/time shown per puzzle (shown in WinModal per user decision; tiles show checkmark only) | SHOULD |`

2. In the Traceability table, REQ-032 already shows `Phase 3 | Complete`. Add an inline note:
   `| REQ-032 | Phase 3 | Complete â€” satisfied via WinModal (tiles show checkmark only per CONTEXT.md) |`

These annotations serve as the authoritative record explaining why the verifier's gap was a false positive and preventing future re-flagging.
  </action>
  <verify>
1. Read .planning/REQUIREMENTS.md and confirm REQ-032 row in both the Puzzles table and Traceability table contains the WinModal annotation
2. `npm run build` still passes (no code was changed)
  </verify>
  <done>REQ-032 rows in REQUIREMENTS.md contain clarifying annotations stating the requirement is satisfied via WinModal per user decision, with tiles showing checkmark only</done>
</task>

</tasks>

<verification>
After both tasks complete:
- ControlBar renders four buttons: Undo, Reset, Menu, Mute
- Mute button toggles between ðŸ”Š/ðŸ”‡ and writes "rushhour_muted" to localStorage
- REQUIREMENTS.md REQ-032 entries annotated with WinModal resolution
- `npm run build` passes cleanly
</verification>

<success_criteria>
1. REQ-051 fully satisfied: game board controls are reset, back (menu), AND mute
2. REQ-032 documented as satisfied via WinModal per user's locked context decision â€” no PuzzleTile code change needed
3. Build passes, no TypeScript errors introduced
</success_criteria>

<output>
After completion, create `.planning/phases/03-puzzle-data-and-navigation/03-04-SUMMARY.md`
</output>
