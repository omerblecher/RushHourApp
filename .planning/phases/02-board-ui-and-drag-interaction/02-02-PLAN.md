---
phase: 02-board-ui-and-drag-interaction
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/hooks/useDrag.ts
  - src/components/Vehicle/Vehicle.tsx
  - src/components/Vehicle/Vehicle.module.css
  - src/components/Board/Board.tsx
  - src/components/Board/Board.module.css
  - src/components/GameHUD/GameHUD.tsx
  - src/components/GameHUD/GameHUD.module.css
  - src/components/ControlBar/ControlBar.tsx
  - src/components/ControlBar/ControlBar.module.css
  - src/App.tsx
  - src/App.module.css
autonomous: true

must_haves:
  truths:
    - "User can drag a vehicle with mouse, constrained to its orientation axis, and it moves in real-time at 60fps"
    - "User can drag a vehicle with touch on mobile, same axis constraint and smoothness"
    - "Vehicle cannot be dragged past another vehicle or wall boundary during drag (hard stop at collision)"
    - "Vehicle snaps to nearest valid grid cell on release with a smooth ease-out animation"
    - "Vehicle lifts with elevation shadow and slight scale during drag"
    - "Vehicle subtly highlights on hover to show it is interactive"
    - "Move counter and timer are visible above the board"
    - "Move counter shows current moves and optimal minimum in 'Moves: N / M min' format"
    - "Undo, reset, and back buttons are visible below the board"
    - "Undo button undoes the last move, reset restores initial state"
  artifacts:
    - path: "src/hooks/useDrag.ts"
      provides: "Custom pointer-event drag hook with axis constraint and collision bounds"
      exports: ["useDrag"]
    - path: "src/components/GameHUD/GameHUD.tsx"
      provides: "Stats bar with move counter and timer"
    - path: "src/components/ControlBar/ControlBar.tsx"
      provides: "Control buttons: undo, reset, back"
  key_links:
    - from: "src/hooks/useDrag.ts"
      to: "src/store/gameStore.ts"
      via: "reads vehicle state for collision pre-computation, calls move() on release"
      pattern: "useGameStore"
    - from: "src/components/Vehicle/Vehicle.tsx"
      to: "src/hooks/useDrag.ts"
      via: "useDrag hook attached to vehicle div ref"
      pattern: "useDrag"
    - from: "src/components/GameHUD/GameHUD.tsx"
      to: "src/store/gameStore.ts"
      via: "reads moveCount and startTime from store"
      pattern: "useGameStore"
    - from: "src/components/ControlBar/ControlBar.tsx"
      to: "src/store/gameStore.ts"
      via: "calls undo() and reset() on store"
      pattern: "useGameStore"
---

<objective>
Wire up the full drag interaction system and game HUD so users can drag vehicles with mouse or touch, constrained to their axis, with real-time collision prevention, snap-to-grid on release, and visual drag feedback. Add the stats bar (move counter + timer) and control buttons (undo, reset, back).

Purpose: Transform the static board from Plan 02-01 into a fully interactive game experience. This completes all Phase 2 requirements.
Output: A playable Rush Hour board where users drag vehicles, see move count and timer, and can undo/reset.
</objective>

<execution_context>
@C:/Users/omerb/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/omerb/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-board-ui-and-drag-interaction/02-RESEARCH.md
@.planning/phases/02-board-ui-and-drag-interaction/02-CONTEXT.md
@.planning/phases/02-board-ui-and-drag-interaction/02-01-SUMMARY.md
@src/engine/types.ts
@src/engine/engine.ts
@src/engine/board.ts
@src/store/gameStore.ts
@src/hooks/useDrag.ts
@src/components/Board/Board.tsx
@src/components/Vehicle/Vehicle.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Custom useDrag hook with axis-constrained pointer-event drag and collision bounds</name>
  <files>
    src/hooks/useDrag.ts
    src/components/Vehicle/Vehicle.tsx
    src/components/Vehicle/Vehicle.module.css
    src/components/Board/Board.tsx
    src/components/Board/Board.module.css
  </files>
  <action>
**src/hooks/useDrag.ts — The core drag hook. This is the most performance-critical code in the app.**

Interface:
```ts
interface UseDragOptions {
  vehicleId: string;
  orientation: 'horizontal' | 'vertical';
  onMoveCommit: (vehicleId: string, newRow: number, newCol: number) => void;
}

function useDrag(options: UseDragOptions): {
  ref: React.RefObject<HTMLDivElement>;
  isDragging: boolean;
}
```

**On pointerdown:**
1. Call `setPointerCapture(e.pointerId)` on the element for reliable tracking
2. Record `startPointerX/Y = e.clientX/Y` and element's current `offsetLeft/offsetTop` (or compute from current grid position)
3. Get board element's bounding rect ONCE (cache it — per research, do NOT call getBoundingClientRect in pointermove)
4. **Pre-compute collision bounds:** Read current vehicles from store. Build occupancy grid. Scan along the vehicle's axis to find the min and max pixel positions it can move to without hitting another vehicle or the wall. Store as `minPx` and `maxPx`. This scan happens ONCE per drag start, not per move frame.
5. Add `will-change: transform` to the element (dynamic, not in static CSS)
6. Apply dragging visual: scale(1.05), elevated box-shadow, z-index: 100

**On pointermove:**
- Compute delta from start pointer position
- If horizontal: `deltaX = e.clientX - startPointerX`, clamp between `minPx` and `maxPx`
- If vertical: `deltaY = e.clientY - startPointerY`, clamp between `minPx` and `maxPx`
- Apply via `element.style.transform = translate(deltaX, 0)` or `translate(0, deltaY)` — DIRECT DOM mutation, NO setState
- This keeps React completely out of the drag loop = 60fps guaranteed

**On pointerup (and pointercancel — same handler, per research):**
1. Remove `will-change: transform`
2. Calculate which grid cell the vehicle center is closest to (snap calculation):
   - `snappedCol = Math.round(currentPixelX / cellSize)` (clamped to valid range)
   - Or for vertical: `snappedRow = Math.round(currentPixelY / cellSize)`
3. If snapped position differs from start position, call `onMoveCommit(vehicleId, newRow, newCol)` which triggers `gameStore.move()`
4. Apply a brief CSS transition (`transform 150ms ease-out`) BEFORE setting the final snap transform, then remove the transition after it completes (setTimeout 150ms). Per user decision: "Smooth animated snap on release"
5. If snapped position equals start position, animate back to origin
6. Remove dragging visual styles (scale, shadow, z-index)
7. Call `releasePointerCapture`

**CRITICAL performance rules (from research):**
- NO `setState` in pointermove — direct DOM only
- NO `getBoundingClientRect` in pointermove — cached from pointerdown
- NO CSS transition during active drag — only on snap
- `touch-action: none` must be in static CSS (already in Vehicle.module.css from Plan 01)
- Handle `pointercancel` identically to `pointerup` to prevent stuck drag state

**isDragging state:** Use a React ref internally for tracking, expose a `useState` boolean for the component to apply CSS classes (this single state change on down/up is acceptable — it's not per-frame).

**Update src/components/Vehicle/Vehicle.tsx:**
- Import and call `useDrag({ vehicleId: vehicle.id, orientation: vehicle.orientation, onMoveCommit })`
- Attach `ref` from useDrag to the vehicle div
- Get `onMoveCommit` from gameStore: `const move = useGameStore(s => s.move)`
- Apply conditional CSS classes based on `isDragging`

**Update src/components/Vehicle/Vehicle.module.css:**
- `.dragging` class: `transform: scale(1.05)`, `box-shadow: 0 8px 24px rgba(0,0,0,0.35)`, `z-index: 100`, cursor: grabbing
- `.vehicle:hover` (per user decision: "Hover highlight — vehicle subtly highlights on hover/tap to show it's interactive"):
  - Slightly brighten (`filter: brightness(1.08)`)
  - Subtle scale (`transform: scale(1.02)`)
  - Quick transition: `transition: filter 0.15s, transform 0.15s`
  - BUT: hover styles must NOT apply during drag (use `:not(.dragging)` selector)

**Update src/components/Board/Board.tsx:**
- Pass `onMoveCommit` callback or ensure Vehicle components can access store directly
- Board must have a `ref` so useDrag can access the board's bounding rect for pixel calculations. Pass board ref via React context or a data attribute on the board DOM element that useDrag can find via `element.closest('[data-board]')`
- Add `data-board` attribute to the board grid container div
- Ensure the board element is findable from within the Vehicle for coordinate calculations

**Update src/components/Board/Board.module.css:**
- Add `.boardWrapper` with `data-board` for useDrag coordinate system reference
  </action>
  <verify>
Run `npm run dev`. In the browser:
1. Click and drag a horizontal vehicle left/right — it follows the pointer along the x-axis only
2. Click and drag a vertical vehicle up/down — it follows the pointer along the y-axis only
3. Drag a vehicle toward another vehicle — it stops at the collision boundary (cannot overlap)
4. Release a vehicle mid-cell — it snaps to the nearest valid grid cell with a brief animation
5. Check that the move counter in the store increments (via React DevTools or console)
6. Test on mobile viewport (Chrome DevTools device mode) — touch drag works identically
7. Open DevTools Performance tab — drag interaction shows consistent 60fps (no long frames)
8. Hover over a vehicle — it subtly highlights
  </verify>
  <done>
Vehicles are draggable via mouse and touch pointer events, constrained to their orientation axis. Collision bounds are pre-computed on drag start for O(1) clamping during drag. Release snaps to nearest grid cell with ease-out animation. Drag visual feedback (lift, shadow, scale) is applied. Hover highlight shows interactivity. 60fps maintained via direct DOM transform mutation.
  </done>
</task>

<task type="auto">
  <name>Task 2: GameHUD (move counter + timer) and ControlBar (undo, reset, back)</name>
  <files>
    src/components/GameHUD/GameHUD.tsx
    src/components/GameHUD/GameHUD.module.css
    src/components/ControlBar/ControlBar.tsx
    src/components/ControlBar/ControlBar.module.css
    src/App.tsx
    src/App.module.css
  </files>
  <action>
**src/components/GameHUD/GameHUD.tsx:**
- Read `moveCount`, `startTime`, `endTime`, `isWon`, and `minMoves` from gameStore
- Display move counter in format: `"Moves: {moveCount} / {minMoves} min"` — per user decision creating a "beat the minimum" motivation loop
- Display timer: elapsed seconds since `startTime` (or 0:00 if not started, or frozen time if won)
- Timer updates via `useEffect` + `setInterval(1000)` — ticks every second while game is active (startTime !== null && endTime === null)
- Timer format: `M:SS` (e.g., `2:05`)
- Clean up interval on unmount and when game is won

**src/components/GameHUD/GameHUD.module.css:**
- `.hud` — flex row, space-between (moves on left, timer on right), width matching board
- Scoreboard feel: dark background strip (e.g., `#3e2723`), white/light text, rounded corners, padding
- Font: monospace for timer, bold for move count
- Subtle styling to look like a scoreboard/display panel above the board

**src/components/ControlBar/ControlBar.tsx:**
- Three buttons: Undo, Reset, Back/Menu
- Undo calls `useGameStore(s => s.undo)` — disabled when `moveHistory.length === 0`
- Reset calls `useGameStore(s => s.reset)` — disabled when `moveCount === 0`
- Back/Menu: for Phase 2, just a placeholder button (no routing yet — Phase 3 adds navigation). Disabled or shows an alert "Menu coming soon" on click.
- Buttons styled as playful, rounded, with icons (use Unicode symbols: ↩ for undo, ↺ for reset, ☰ for menu — no icon library needed)
- Per user decision: "Control buttons below the board — button row underneath, out of the way but easy to reach"

**src/components/ControlBar/ControlBar.module.css:**
- `.controlBar` — flex row, justify-center, gap between buttons, width matching board
- `.button` — large touch target (min 44x44px for mobile), rounded, playful colors
- `.button:disabled` — reduced opacity, cursor: not-allowed
- `.button:active` — slight scale-down press effect
- Matching visual theme with HUD (dark/warm tones)

**Update src/App.tsx:**
- Layout: GameHUD above Board, Board in middle, ControlBar below
- Flex column layout in the app wrapper
- Gap between sections for clean spacing
- Pass `minMoves` to store on puzzle load (hardcode a value like 8 for the test puzzle, or 0 if unknown)

**Update src/App.module.css:**
- `.app` — flex column, align-items center, gap between HUD/Board/Controls
- Ensure all three sections (HUD, Board, Controls) share the same max-width as the board

**Also update src/store/gameStore.ts if needed:**
- Ensure `minMoves` is stored and accessible
- Ensure `moveHistory` is accessible for undo button disabled state (expose `moveHistory.length` or a `canUndo` boolean)
  </action>
  <verify>
Run `npm run dev`. In the browser:
1. See "Moves: 0 / 8 min" (or similar) in the HUD above the board — timer shows 0:00
2. Drag a vehicle to a new position — move counter increments to 1, timer starts counting
3. Drag another vehicle — counter shows 2
4. Click Undo — vehicle returns to previous position, counter increments (per engine behavior)
5. Click Reset — all vehicles return to initial positions, counter resets to 0, timer resets
6. Undo button is disabled when no moves have been made
7. Reset button is disabled when counter is 0
8. Back/Menu button is present but non-functional (placeholder)
9. All controls are easily tappable on mobile viewport (44px+ touch targets)
10. `npx tsc --noEmit` passes
  </verify>
  <done>
GameHUD displays move counter ("Moves: N / M min" format) and running timer above the board. ControlBar shows undo, reset, and back buttons below the board with proper disabled states. The full game loop works: drag vehicles, see moves count up, use undo/reset, timer tracks elapsed time. All requirements for Phase 2 are implemented.
  </done>
</task>

</tasks>

<verification>
1. `npm run dev` starts and shows the full game UI: HUD + Board + Controls
2. Drag a horizontal vehicle left/right — stays on axis, stops at collisions
3. Drag a vertical vehicle up/down — stays on axis, stops at collisions
4. Release mid-cell — vehicle snaps to nearest valid grid cell with smooth animation
5. Vehicle lifts (scale + shadow) during drag, returns to normal on release
6. Hover over vehicle — subtle highlight effect (brightness + slight scale)
7. Move counter increments on each successful drag-to-new-position
8. Timer starts on first move, displays M:SS format
9. HUD shows "Moves: N / M min" format
10. Undo reverses last move and increments counter
11. Reset restores initial puzzle state, zeros counter and timer
12. Back button present (placeholder)
13. Touch drag works in Chrome DevTools device emulation
14. 60fps during drag (no layout thrashing — check Performance tab)
15. `npx tsc --noEmit` passes with no errors
</verification>

<success_criteria>
The Rush Hour board is fully interactive: vehicles drag with mouse and touch, constrained to axis, with collision prevention, snap-to-grid, and visual feedback. HUD shows move counter with optimal comparison and running timer. Control buttons enable undo/reset. All Phase 2 requirements (REQ-011 through REQ-024, NFR-001, NFR-008) are satisfied.
</success_criteria>

<output>
After completion, create `.planning/phases/02-board-ui-and-drag-interaction/02-02-SUMMARY.md`
</output>
